#include <unordered_map>
#include <vector>
#include <iostream>
#include <algorithm>
#include <string>
#include <queue>
#include <stack>
#include <set>
#include <functional>
#include <unordered_set>
using namespace std;

struct ListNode {
	int val;
	ListNode *next;
	ListNode(int x) : val(x), next(NULL) {}
};
//ListNode* p = head->next;
//p = NULL;    //head->next remains the same
//ListNode** pp = &(head->next);
//*pp = NULL;  //head->next changed

struct TreeNode {
	int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

struct TreeLinkNode {
	TreeLinkNode *left;
    TreeLinkNode *right;
    TreeLinkNode *next;
};

struct Interval {
	int start;
	int end;
	Interval() : start(0), end(0) {}
	Interval(int s, int e) : start(s), end(e) {}
};

//Union Find
class UnionFind {
private:
	vector<int> id;
	vector<int> sz;
	int count;
public:
	UnionFind(int n) : count(n) {
		id = vector<int>(n);
		sz = vector<int>(n, 1);
		for (int i = 0; i < n; i++) {
			id[i] = i;
		}
	}

	int root(int i) {
		while (i != id[i]) {
			id[i] = id[id[i]];
			i = id[i];
		}
		return i;
	}

	void connect(int p, int q) {
		int i = root(p);
		int j = root(q);
		if (i == j) return;
		if (sz[i] < sz[j]) {
			id[i] = j;
			sz[j] += sz[i];
		}
		else {
			id[j] = i;
			sz[j] += sz[i];
		}
		count--;
	}

	bool isConnected(int p, int q) {
		return (root(p) == root(q));
	}
	int getCount() {
		return count;
	}
};

class Solution1 {
public:
	string longestPalindrome(string s) {
		if (s.empty()) return "";
		int start = 0;
		int longest = 1;
		for (int i = 1; i < s.size(); i++) {
			if ((s.size() - i) * 2 - 1 < longest)
				break;
			int j = i - 1;
			int k = i + 1;
			while ((j >= 0) && (s[j] == s[i])) {
				j--;
			}
			while ((k<s.size()) && (s[k] == s[i])) {
				k++;
			}
			i = k - 1;
			while ((j >= 0) && (k < s.size()) && (s[j] == s[k])) {
				j--;
				k++;
			}
			if (k - j - 1 > longest) {
				start = j + 1;
				longest = k - j - 1;
			}
		}
		return s.substr(start, longest);
	}
};

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution2 {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode *root = new ListNode(0);
		ListNode *p = root;
		int c = 0;
		while(l1 || l2 || c){
			if(l1) c += l1->val, l1 = l1->next;
			if(l2) c += l2->val, l2 = l2->next;
			ListNode *digit = new ListNode(c%10);
			p->next = digit;
			p = p->next;
			c = c/10;
		}
		return root->next;
        
    }
};

class Solution4 {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
     int m,n,k;
    m = nums1.size();
    n = nums2.size();
    auto beg1 = nums1.begin(),beg2 = nums2.begin();
    k = (m+n)>>1;
    if((m+n) & 0x1)
        return find_kth(nums1,beg1,nums2,beg2,k+1);
    else 
        return (find_kth(nums1,beg1,nums2,beg2,k) + find_kth(nums1,beg1,nums2,beg2,k+1))/2.0;

        
    }
    private:
double find_kth(vector<int>& nums1,vector<int>::iterator beg1,vector<int>& nums2,vector<int>::iterator beg2,int k)
{
    int m = nums1.end() - beg1,n = nums2.end() - beg2;
    if(m>n) 
        return find_kth(nums2,beg2,nums1,beg1,k);
    if(m==0) return *(beg2+k-1);
    if(k==1) return min(*beg1,*beg2);
    int m1 = min(k/2,m),m2 = k-m1;
    if(*(beg1+m1-1)<*(beg2+m2-1))
        return find_kth(nums1,beg1+m1,nums2,beg2,k-m1);
    else if(*(beg1+m1-1)>*(beg2+m2-1))
        return find_kth(nums1,beg1,nums2,beg2+m2,k-m2);
    else
        return *(beg1+m1-1);
}
        
};

class Solution4_01 {
public:
    double findKth(vector<int>& nums1, vector<int>& nums2, vector<int>::iterator st1, vector<int>::iterator st2, int k){
        if (st1 == nums1.end()) return *(st2 + k - 1);
        if (st2 == nums2.end()) return *(st1 + k - 1);
        if (k == 1) return min(*st1, *st2);
        int len1 = nums1.end() - st1, len2 = nums2.end() - st2;
        int med1 = min(len1, k/2), med2 = min(len2, k/2);
        if (*(st1 + med1 - 1) < *(st2 + med2 - 1)) return findKth(nums1, nums2, st1 + med1, st2, k - med1);
        else return findKth(nums1, nums2, st1, st2 + med2, k - med2);
    }
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int l1 = nums1.size(), l2 = nums2.size();
        int k = (l1 +l2) >> 1;
        vector<int>::iterator it1 = nums1.begin(), it2 = nums2.begin();
        if ((l1 + l2) % 2 == 1) return findKth(nums1, nums1, it1, it2, k + 1);
        else return (findKth(nums1, nums2, it1, it2, k) + findKth(nums1, nums2, it1, it2, k + 1)) / 2.0;
    }
    
  
        
};

class Solution6 {
public:
	string convert(string s, int numRows) {
		if (numRows == 1) return s;
		string res = "";
		string* rows = new string[numRows];
		int dir = 1;
		int k = 0;
		for (int i = 0; i < s.size(); i++) {
			rows[k].push_back(s[i]);
			if ((k + dir < 0) || (k + dir >= numRows)) {
				dir = -dir;
			}
			k = k + dir;
		}

		for (int i = 0; i < numRows; i++) {
			res += rows[i];
		}
		return res;
	}
};
class Solution7 {
public:
	int reverse(int x) {
		long res = 0;
		while (x != 0) {
			res = res * 10 + x % 10;
			x /= 10;
		}
		res = ((res > INT_MAX) || (res < INT_MIN)) ? 0 : res;
		return res;
	}
};
class Solution8 {
public:
	int myAtoi(string str) {
		int k = 0;
		int sign = 1;
		long res = 0;
		while (k<str.size() && str[k] ==' ') {
			k++;
		}
		if (str[k] == '-') sign = -1, k++;
		else if (str[k] == '+') k++;
		while (k < str.size() && str[k]>='0' && str[k] <= '9') {
			res = res * 10 + sign * (str[k] - '0');
			if (res > INT_MAX) return INT_MAX;
			if (res < INT_MIN) return INT_MIN;
			k++;
		}
		return res;

	}
};

class Solution9 {
public:
	bool isPalindrome(int x) {
		if ((x < 0) || (x>0) && x%10==0) return false;
		int res = 0;
		while (res < x) {
			res = res * 10 + x % 10;
			x /= 10;
		}
		return (res == x) || (res/10 == x);
	}
};

/*
Solution10 sln10;
string s1 = "aab";
string s2 = "c*a*b";
int x = 10;
cout << sln10.isMatch(s1, s2) << endl;
*/
class Solution10 {
private:
	bool isTokenMatch(string s, string token) {
		char ch = token[0];
		if (token.size()==1) {
			return (s.size() == 1) && ((ch == '.')||(s== token));
		}
		else {
			bool flag = false;
			if (ch == '.') return true;
			for (int i = 0; i < s.size(); i++) {
				if (s[i] != ch)
					return false;
			}
			return true;
		}
	}
	vector<string> getTokens(string p) {
		vector<string> tokens;
		int k = 0;
		while (k < p.size()) {
			string token;
			token.push_back(p[k++]);
			if ((k<p.size()) && (p[k] == '*')) {
				token.push_back(p[k++]);
			}
			tokens.push_back(token);
		}
		return tokens;
	}
public:
	bool isMatch(string s, string p) {
		vector<string> tokens;
		tokens = getTokens(p);
		vector<vector<bool>> dp;
		for (int i = 0; i < s.size() + 1; i++) {
			vector<bool> v1(tokens.size() + 1, false);
			dp.push_back(v1);
		}

		dp[s.size()][tokens.size()] = true;
		for (int j = tokens.size() - 1; j >= 0; j--) {
			dp[s.size()][j] = dp[s.size()][j + 1] && (tokens[j].size() == 2);
		}

		for (int i = s.size() - 1; i >= 0; i--) {
			for (int j = tokens.size() - 1; j >= 0; j--) {
				if (tokens[j].size() == 1) {
					dp[i][j] = isTokenMatch(s.substr(i, 1), tokens[j]) && (dp[i+1][j+1]);
				}
				else {
					dp[i][j] = dp[i][j+1] || 
						(isTokenMatch(s.substr(i, 1), tokens[j]) && ((dp[i+1][j+1])||(dp[i+1][j])));
				}
			}
		}
		return dp[0][0];
	}
};

class Solution10_01 {
private:
    bool isMatch(const char* s, const char* p) {
        if (p[0] == '\0') return (s[0] == '\0');
        if (s[0] == '\0') {
            if (p[1] == '*') return isMatch(s, p + 2);
            else return false;
        }
        if (p[0] == '.' || p[0] == s[0]) {
            if (p[1] != '*') return isMatch(s + 1, p + 1);
            else {
                int k = 0;
                while (k < strlen(s) && (p[0] == '.' || s[k] == p[0])) {
                    if (isMatch(s + k + 1, p + 2)) return true;
                    else k++;
                }
                return isMatch(s, p + 2);
            }
        }
        else if (p[1] == '*') return isMatch(s, p + 2);
        else return false;
    }    
public:
    bool isMatch(string s, string p) {
        return isMatch(s.c_str(), p.c_str());
        if (p.size() == 0) return (s.size() == 0);
        if (s.size() == 0) {
            if (p.size() > 1 && p[1] == '*' ) 
                return isMatch(s, p.substr(2, p.size() - 2));
            else return false;
        }
        if (p[0] == s[0] || p[0] == '.') {
            if (p.size() == 1) return (s.size() == 1);
            if (p[1] != '*')
                return isMatch(s.substr(1, s.size() - 1), p.substr(1, p.size() - 1));
            else {
                int k = 0;
                bool found = false;
                while (k < s.size() && (p[0] == '.' || s[k] == p[0]) 
                && !(found = isMatch(s.substr(k + 1, s.size() - k - 1), p.substr(2, p.size() - 2))))
                    k++;
                return (found || isMatch(s, p.substr(2, p.size() - 2)));
            }
        }
        else if (p.size() > 1 && p[1] == '*') return isMatch(s, p.substr(2, p.size() - 2));
        else return false;
    }
};


class Solution10_02 {
public:
	bool isMatch(string s, string p) {
		if (p.empty()) return s.empty();
		if (s.empty() || (p[0] != '.' && s[0] != p[0])) return (p.size() > 1 && p[1] == '*' && isMatch(s, p.substr(2)));
		if (p[0] == '.' || s[0] == p[0]) {
			if (p.size() == 1 || p[1] != '*') return isMatch(s.substr(1), p.substr(1));
			int i = 0;
			while (i <= s.size() && (i == 0 || p[0] == '.' || s[i - 1] == p[0])) {
				if (isMatch(s.substr(i), p.substr(2))) return true;
				i++;
			}
		}
		return false;
	}
};

class Solution10_dp {
public:
	bool isMatch(string s, string p) {
		//f[i][j]   s[0..i-1] matchs p[0..j-1];
		int n = s.size(), m = p.size();
		vector<vector<bool>> f(n + 1, vector<bool>(m + 1, false));
		f[0][0] = true;
		for (int j = 2; j <= m; j += 2) {
			f[0][j] = (f[0][j - 2] && p[j - 1] == '*');
		}

		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				if (p[j] != '*') {
					f[i][j] = f[i - 1][j - 1] && (p[j - 1] == '.' || s[i - 1] == p[j - 1]);
				}
				else {
					f[i][j + 1] = f[i][j - 1] || ((p[j - 1] == '.' || s[i - 1] == p[j - 1]) && (f[i - 1][j - 1] || f[i - 1][j + 1]));
					j++;
				}
			}
		}
		return f[n][m];
	}
};

class Solution14 {
public:
    string longestCommonPrefix(vector<string>& strs) {
        if (strs.empty()) return "";
        if (strs.size() == 1) return strs[0];
        string res = "";
        int k = 0;
        while(1) {
            char c = '\0';
            for(int i = 0; i < strs.size(); i++) {
                if (!c && k < strs[i].size()) c = strs[i][k];
                else if (k >= strs[i].size() || strs[i][k] != c)
                    return res;
            }
            res.push_back(c);
			k++;
        }
    }
};

class Solution17 {
public:
	void dfs(string table[], string digits, string res, vector<string> &ans) {
		if (digits.empty()) {
			if (!res.empty()) ans.push_back(res);
			return;
		}
		int digit = digits[0] - '0';
		for (int i = 0; i < table[digit].size(); i++) {
			dfs(table, digits.substr(1,digits.size()-1), res+table[digit][i], ans);
		}
	}
	vector<string> letterCombinations(string digits) {
		string table[10] = {"0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
		vector<string> ans;
		string res = "";
		dfs(table, digits, res, ans);
		return ans;
	}
};

class Solution19 {
public:
	ListNode* removeNthFromEnd(ListNode* head, int n) {
		ListNode* preHead = new ListNode(0);
		preHead -> next = head;
		ListNode* node1 = preHead;
		ListNode* node2 = preHead;
		while (n > 0) {
			node2 = node2->next;
			n--;
		}
		while (node2->next) {
			node1 = node1->next;
			node2 = node2->next;
		}
		ListNode* toDelete = node1->next;
		//node1->next = node1->next->next;
		ListNode** a1 = &(node1->next);
		*a1 = ((*a1)->next);
		delete toDelete;
		return preHead->next;
	}
};

class Solution20 {
public:
	bool isValid(string s) {
		stack<char> st;
		for (int i = 0; i < s.size(); i++) {
			if  (((s[i] == ')') && ((st.empty()) || (st.top() !='('))) 
				|| ((s[i] == ']') && ((st.empty()) || (st.top() != '[')))
				|| ((s[i] == '}') && ((st.empty()) || (st.top() != '{')))) {
				return false;
			}
			if ((s[i] == '(') || (s[i] == '[') || (s[i] == '{')) {
				st.push(s[i]);
			}else {
				st.pop();
			}
		}
		return st.empty();
	}
};

class Solution20_01 {
public:
	bool isValid(string s) {
		stack<char> stk;
		stk.push('#');
		for (int i = 0; i < s.size(); i++) {
			if ((s[i] == ')' && stk.top() != '(') || (s[i] == ']' && stk.top() != '[') || (s[i] == '}' && stk.top() != '{')) {
				return false;
			}
			if ((s[i] == '(') || (s[i] == '[') || (s[i] == '{')) {
				stk.push(s[i]);
			}
			else { stk.pop(); }
		}
		return (stk.top() == '#');
	}
};

class Solution22_02 {
public:
	vector<string> generateParenthesis(int n) {
		vector<vector<string>> f;
		f.push_back(vector<string>(1, ""));
		f.push_back(vector<string>(1, "()"));

		for (int i = 2; i <= n; i++) {
			vector<string> temp;
			for (int j = i-1; j>=0; j--) {
				for (int a = 0; a < f[j].size(); a++) {
					for (int b = 0; b < f[i - j -1].size(); b++) {
						temp.push_back("("+f[j][a]+")"+f[i-j-1][b]);
					}
				}
			}
			f.push_back(temp);
		}
		return f[n];

	}
};

class Solution23 {
public:
	struct compare {
		bool operator() (ListNode* l1, ListNode* l2) {
			return (l1->val > l2->val);
		}
	};
	ListNode* mergeKLists(vector<ListNode*>& lists) {
		ListNode* head = NULL;
		ListNode** it = &head;
		priority_queue<ListNode*, vector<ListNode*>, compare> q;
		for (int i = 0; i < lists.size(); i++) {
			if (lists[i]) q.push(lists[i]);
		}
		while (!q.empty()) {
			*it = q.top();
			q.pop();
			if ((*it)->next) {
				q.push((*it)->next);
			}
			it = &((*it)->next);
		}
		return head;
	}
};

/*
class Solution30 {
public:
	vector<int> findSubstring(string s, vector<string>& words) {
		vector<int> res;
		unordered_map<string, int> map;
		for (auto s : words) {
			map[s]++;
		}
		int wordLen = words[0].size();
		int windowLen = wordLen * words.size();
		for (int i = 0; i < s.length() - windowLen + 1; i++) {
			unordered_map<string, int> count;
			for (int j = 0; j < words.size(); j++) {
				string word = s.substr(i + j*wordLen, wordLen);
				if (map.find(word) != map.end()) {
					count[word]++;
					if (count[word] > map[word])
						break;
					if (j == words.size() - 1) {
						res.push_back(i);
					}
				}
				else break;
			}
		}
		return res;
	}
};
*/

class Solution31 {
public:
	void nextPermutation(vector<int>& nums) {
		if (nums.empty()) return;
		int d1 = nums[nums.size() - 1];
		int p1 = nums.size() - 1;
		for (int i = nums.size() - 2; i >= 0; i--) {
			if (nums[i] < nums[i + 1]) {
				d1 = nums[i];
				p1 = i;
				break;
			}
		}
		if (p1 == nums.size() - 1) {
			reverse(nums.begin(), nums.end());
			return;
		}
		for (int i = nums.size() - 1; i >= 0; i--) {
			if (nums[i] > d1) {
				swap(nums[p1], nums[i]);
				reverse(nums.begin() + p1 + 1, nums.end());
				break;
			}
		}
	}
};

class Solution31_1 {
public:
	void nextPermutation(vector<int>& nums) {
		if (nums.empty()) return;
		vector<int>::reverse_iterator p1 = is_sorted_until(nums.rbegin(), nums.rend());
		if (p1 == nums.rend()) {
			reverse(nums.begin(), nums.end());
			return;
		}
		swap(*p1, *upper_bound(nums.rbegin(), p1, *p1));
		reverse(nums.rbegin(), p1);
	}
};

class Solution31_02 {
public:
    void nextPermutation(vector<int>& nums) {
        if (nums.size() < 2) return;
        int k = nums.size() - 2;
        while(k >= 0 && nums[k] >= nums[k + 1]) k--;
        if (k < 0) sort(nums.begin(), nums.end());
        else {
            int t = nums.size() - 1;
            while (nums[t] <= nums[k]) t--;
            swap(nums[k], nums[t]);
            sort(nums.begin() + k + 1, nums.end());
        }
    }
};

class Solution31_03 {
public:
    void nextPermutation(vector<int>& nums) {
        if (nums.empty()) return;
        vector<int>::reverse_iterator i = is_sorted_until(nums.rbegin(), nums.rend());
        if (i == nums.rend()) {
            reverse(nums.begin(), nums.end());
            return;
        }
        vector<int>::reverse_iterator t = upper_bound(nums.rbegin(), nums.rend(), *i);
        swap(*i, *t);
        reverse(nums.rbegin(), i);
    }
};

class Solution32 {
public:
	int longestValidParentheses(string s) {
		stack<int> stk;
		int res = 0;
		for (int i = 0; i < s.size();i ++) {
			if ((s[i] == '(') || (stk.empty())) {
				stk.push(i);
			}
			else if ((!stk.empty()) && (s[stk.top()] == '(')) {
				stk.pop();
			}
			else stk.push(i);
		}
		if (stk.empty()) return s.size();
		res = 0;
		int k = s.size();
		while (!stk.empty()) {
			res = max(res, int(k - stk.top() - 1));
			k = stk.top();
			stk.pop();
		}
		return max(res,k);
	}
};

class Solution32_00 {
public:
    int longestValidParentheses(string s) {
        int res = 0;
        stack<int> stk;
        for(int i = 0; i < int(s.size()); i++) {
            if (s[i] == '(') stk.push(i);
            else if (stk.empty() || s[stk.top()] == ')') stk.push(i);
            else stk.pop();
        }
        int last = (int)s.size();
        while(!stk.empty()) {
            res = max(res, last - stk.top() - 1);
            last = stk.top();
            stk.pop();
        }
        res = max(res, last);
        return res;
    }
};

class Solution32_01 {  //72ms
public:
	int longestValidParentheses(string s) {
		int res = 0;
		unordered_map<int, int> dp;
		dp.insert(pair<int, int>(-1, 0));
		dp[0] = 0;
		for (int i = 1; i < s.size(); i++) {
			if ((s[i]) == '(') {
				dp[i] = 0; 
				continue;
			}
			else if (s[i - 1] == '(') {
				dp[i] = dp[i - 2] + 2;
			}
			else if (s[i - 1] == ')') {
				if ((i - dp[i - 1] - 1 >= 0)&&(s[i - dp[i - 1] - 1] == '(')) {
					dp[i] = dp[i - 1] + 2 + dp[i - dp[i - 1] - 2];
				}
			}
		}
		for (int i = 0; i < s.size(); i++) {
			res = max(res, dp[i]);
		}
		return res;
	}
};

class Solution32_02 {
public:
	int longestValidParentheses(string s) {
		int res = 0;
		vector<int> dp(s.size(), 0);
		for (int i = 1; i < s.size(); i++) {
			if ((s[i]) == '(') {
				dp[i] = 0;
				continue;
			}
			else if (s[i - 1] == '(') {
				if (i-2>=0) dp[i] = dp[i - 2] + 2;
				else dp[i] = 2;
			}
			else if (s[i - 1] == ')') {
				if ((i - dp[i - 1] - 1 >= 0) && (s[i - dp[i - 1] - 1] == '(')) {
					if (i - dp[i - 1] - 2 >= 0) dp[i] = dp[i - 1] + 2 + dp[i - dp[i - 1] - 2];
					else dp[i] = dp[i - 1] + 2;
				}
			}
		}
		for (int i = 0; i < s.size(); i++) {
			res = max(res, dp[i]);
		}
		return res;
	}
};

class Solution32_002 {
public:
    int longestValidParentheses(string s) {
        int res = 0;
        vector<int> f(s.size(), 0);
        for(int i = 1; i < s.size(); i++) {
            if (s[i] == '(') f[i] = 0;
            else {
                int temp = i - 1 - f[i - 1];
                if (temp >= 0 && s[temp] == '(') {
					f[i] = f[i - 1] + 2 + ((temp > 0) ? f[temp - 1] : 0);
				}
                else f[i] = 0;
                res = max(res, f[i]);
            }
        }
        return res;
    }
};

class Solution32_03{
public:
    int longestValidParentheses(string s) {
        int res = 0;
        stack<int> stk;
        stk.push(0);
        //-1 for (   
        //-2 for )
        for(int i = 0; i < int(s.size()); i++) {
            if (s[i] == '(') stk.push(-1);
            else{
                if (stk.top() == 0 || stk.top() == -2) stk.push(-2);
                else if (stk.top() == -1) {
                    int temp = 2;
                    stk.pop();
                    if (stk.top() > 0) temp += stk.top(), stk.pop();
                    stk.push(temp);
                    res = max(res, temp);
                }
                else {
                    int temp = stk.top();
                    stk.pop();
                    if (stk.top() == -2 || stk.top() == 0) stk.push(temp), stk.push(-2);
                    else {
                        temp += 2;
                        stk.pop();
                        if (stk.top() > 0) temp += stk.top(), stk.pop();
                        stk.push(temp);
                        res = max(res, temp);
                    }
                }
            }
        }
        return res;
    }
};

class Solution33 {
public:
	int bSearch(vector<int> &nums, int l, int r, int target) {
		if (l == r) {
			return (nums[l] == target) ? l : -1;
		}
		int m = (l + r) / 2;
		if (nums[m] < nums[l]) {
			if ((nums[m] < target) && (target <= nums[r]))
				return bSearch(nums, m+1, r, target);
			else return bSearch(nums, l, m, target);
		}
		else {
			if ((nums[l] <= target) && (target <= nums[m]))
				return bSearch(nums, l, m, target);
			else return bSearch(nums, m+1, r, target);
		}
	}
	int search(vector<int>& nums, int target) {
		if (nums.empty()) return -1;
		return bSearch(nums, 0, nums.size()-1, target);
	}
};

class Solution33_01 {
public:
	int bSearch(vector<int> &nums, int l, int r, int target) {
		if (l == r) {
			return (nums[l] == target) ? l : -1;
		}
		int m = (l + r) / 2;
		if (nums[m] < nums[l]) {
			if ((nums[m] < target) && (target <= nums[r]))
				return bSearch(nums, m + 1, r, target);
			else return bSearch(nums, l, m, target);
		}
		else {
			if ((nums[l] <= target) && (target <= nums[m]))
				return bSearch(nums, l, m, target);
			else return bSearch(nums, m + 1, r, target);
		}
	}
	int search(vector<int>& nums, int target) {
		if (nums.empty()) return -1;
		int l = 0, r = nums.size() -1;
		int m = 0;
		while (l < r) {
			m = (l + r) / 2;
			if (nums[m] < nums[l]) {
				if ((nums[m] < target) && (target <= nums[r]))
					l = m + 1;
				else r = m;
			}
			else {
				if ((nums[l] <= target) && (target <= nums[m]))
					r = m;
				else l = m + 1;
			}
		}
		return (nums[l] == target) ? l : -1;
	}
};

class Solution33_02 {
public:
    int search(vector<int>& nums, int target) {
        int l = 0, r = nums.size() - 1;
        while (l <= r){
            int m = l + (r - l) / 2;
            if (target == nums[m]) return m;
            if (nums[l] <= nums[m]) {
                if (nums[l] <= target && target < nums[m]) r = m - 1;
                else l = m + 1;
            }
            else {
                if (nums[m] < target && target <= nums[r]) l = m + 1;
                else r = m - 1;
            }
        }
        return -1;
    }
};

class Solution34 {
public:
	vector<int> searchRange(vector<int>& nums, int target) {
		vector<int> res;
		if (nums.empty()) return vector<int>(2, -1);
		int l = 0, r = nums.size() - 1;
		int m = 0;
		while (l < r) {
			int m = (l + r) / 2;
			if (target <= nums[m]) r = m;
			else if (target>nums[m]) l = m+1;
		}
		if (nums[l] != target) return vector<int>(2, -1);
		res.push_back(l);
		while (l+1 < nums.size() && nums[l+1] == target) {
			l++;
		}
		res.push_back(l);
		return res;
	}
};

class Solution34_01 {
public:
	vector<int> searchRange(vector<int>& nums, int target) {
		vector<int> res;
		if (nums.empty()) return vector<int>(2, -1);
		auto l = lower_bound(nums.begin(), nums.end(), target);
		auto r = upper_bound(nums.begin(), nums.end(), target);
		if (l != nums.end() && *l == target) {
			res.push_back(distance(nums.begin(), l));
			res.push_back(distance(nums.begin(), r) - 1);
		}
		else { 
			res.push_back(-1);
			res.push_back(-1);
		};
		return res;
	}
};

class Solution35 {
public:
	int searchInsert(vector<int>& nums, int target) {
		if (nums.empty()) return 0;
		int l = 0, r = nums.size() - 1;
		int m = 0;
		while (l < r) {
			m = (l + r) / 2;
			if (target <= nums[m]) r = m;
			else l = m + 1;
		}
		return nums[l] >= target ? l : l + 1;
	}
};

class Solution36 {
public:
	bool isValidSudoku(vector<vector<char>>& board) {
		set<int> checkSet[3][9];
		for (int i = 0; i < 9; i++) {
			for (int j = 0; j < 9; j++){
				int k = (i / 3) * 3 + (j / 3);
				if (board[i][j] == '.') continue;
				int d = board[i][j] - '0';
				if (checkSet[0][i].find(d) != checkSet[0][i].end())
					return false;
				else checkSet[0][i].insert(d);
				if (checkSet[1][j].find(d) != checkSet[1][j].end())
					return false;
				else checkSet[1][j].insert(d);
				if (checkSet[2][k].find(d) != checkSet[2][k].end())
					return false;
				else checkSet[2][k].insert(d);
			}
		}
		return true;
	}
};

/*
Solution37 sln37;
vector<vector<char>> board;
char* ch1 = "..9748...";
char* ch2 = "7........";
char* ch3 = ".2.1.9...";
char* ch4 = "..7...24.";
char* ch5 = ".64.1.59.";
char* ch6 = ".98...3..";
char* ch7 = "...8.3.2.";
char* ch8 = "........6";
char* ch9 = "...2759..";
board.push_back(vector<char>(ch1, ch1 + 9));
board.push_back(vector<char>(ch2, ch2 + 9));
board.push_back(vector<char>(ch3, ch3 + 9));
board.push_back(vector<char>(ch4, ch4 + 9));
board.push_back(vector<char>(ch5, ch5 + 9));
board.push_back(vector<char>(ch6, ch6 + 9));
board.push_back(vector<char>(ch7, ch7 + 9));
board.push_back(vector<char>(ch8, ch8 + 9));
board.push_back(vector<char>(ch9, ch9 + 9));
sln37.solveSudoku(board);
*/
class Solution37 {
public:
	bool isValidSudoku(vector<vector<char>>& board) {
		set<int> checkSet[3][9];
		for (int i = 0; i < 9; i++) {
			for (int j = 0; j < 9; j++) {
				int k = (i / 3) * 3 + (j / 3);
				if (board[i][j] == '.') continue;
				int d = board[i][j] - '0';
				if (checkSet[0][i].find(d) != checkSet[0][i].end())
					return false;
				else checkSet[0][i].insert(d);
				if (checkSet[1][j].find(d) != checkSet[1][j].end())
					return false;
				else checkSet[1][j].insert(d);
				if (checkSet[2][k].find(d) != checkSet[2][k].end())
					return false;
				else checkSet[2][k].insert(d);
			}
		}
		return true;
	}
	void dfs(vector<vector<char>>& board, set<int> checkSet[][9], int n, bool& solved) {
		if (n == 81) { 
			solved = true; 
			return; 
		}
		int i = n / 9, j = n % 9, k = (i / 3) * 3 + (j / 3);
		if (board[i][j] != '.') dfs(board, checkSet, n + 1, solved);
		else {
			for (int d = 1; d <= 9; d++) {
				if (!solved && checkSet[0][i].find(d) == checkSet[0][i].end() && checkSet[1][j].find(d) == checkSet[1][j].end() && checkSet[2][k].find(d) == checkSet[2][k].end()) {
					board[i][j] = '0' + d;
					checkSet[0][i].insert(d);
					checkSet[1][j].insert(d);
					checkSet[2][k].insert(d);
					dfs(board, checkSet, n + 1, solved);
					if (solved) return;
					else { 
						board[i][j] = '.'; 
						checkSet[0][i].erase(d);
						checkSet[1][j].erase(d);
						checkSet[2][k].erase(d);
					}
				}
			}
		}
	}
	void solveSudoku(vector<vector<char>>& board) {
		set<int> checkSet[3][9];
		bool solved = false;
		for (int i = 0; i < 9; i++) {
			for (int j = 0; j < 9; j++) {
				int k = (i / 3) * 3 + (j / 3);
				if (board[i][j] == '.') continue;
				int d = board[i][j] - '0';
				checkSet[0][i].insert(d);
				checkSet[1][j].insert(d);
				checkSet[2][k].insert(d);
			}
		}
		dfs(board, checkSet, 0, solved);
	}
};

class Solution38 {
public:
	string countAndSay(int n) {
		if (n == 0) return "";
		string pre = "1";
		string cur = "";
		while (n-- > 1) {
			int k = 1;
			char c = pre[0];
			int count = 1;
			while (k < pre.size()) {
				if (pre[k] == pre[k - 1]) {
					count++; k++; continue;
				}
				cur += '0' + count;
				cur += c;
				c = pre[k]; count = 1; k++;
			}
			cur += '0' + count;
			cur += c;
			pre = cur;
			cur = "";
		}
		return pre;
	}
};

class Solution38_01 {
public:
    string countAndSay(int n) {
        if (n == 1) return "1";
        string res = "1";
        while(--n) {
            string temp = res;
            res = "";
            int count = 1;
            for(int i = 1; i < temp.size(); i++) {
                if (temp[i] == temp[i - 1]) {count++; continue;}
                else { 
                    res += '0' + count;
                    res += temp[i - 1];
                    count = 1;
                }
            }
			res += '0' + count;
            res += temp[temp.size() - 1];
        }
        return res;
    }
};

class Solution39 {
public:
	void dfs(vector<vector<int>>& res, vector<int>& ans, vector<int>& candidates, int target, int k, int sum) {
		if (sum == target) {
			res.push_back(ans);
			return;
		}
		for (int i = k; i < candidates.size(); i++) {
			if (sum + candidates[i] <= target) {
				ans.push_back(candidates[i]);
				dfs(res, ans, candidates, target, i, sum + candidates[i]);
				ans.pop_back();
			}
		}
	}
	vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
		vector<vector<int>> res;
		vector<int> ans;
		sort(candidates.begin(), candidates.end());
		dfs(res, ans, candidates, target, 0, 0);
		return res;
	}
};

class Solution39_01 {
public:
	vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
		vector<vector<vector<int>>> dp(target + 1, vector<vector<int>>());
		sort(candidates.begin(), candidates.end());
		
		for (int i = 0; i < candidates.size(); i++){}

		return dp[target];
	}
};

class Solution40 {
public:
	void dfs(vector<vector<int>>& res, vector<int>& ans, vector<int>& candidates, int target, int k, int sum) {
		if (sum == target) {
			res.push_back(ans);
			return;
		}
		for (int i = k; i < candidates.size(); i++) {
			if (i == k || candidates[i - 1] != candidates[i]) {
				if (sum + candidates[i] <= target) {
					ans.push_back(candidates[i]);
					dfs(res, ans, candidates, target, i + 1, sum + candidates[i]);
					ans.pop_back();
				}
			}
		}
	}
	vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
		vector<vector<int>> res;
		vector<int> ans;
		sort(candidates.begin(), candidates.end());
		dfs(res, ans, candidates, target, 0, 0);
		return res;
	}
};

class Solution44 {
public:
	//why it is ok to update the star pos
	//suppose we have
	//...|...c......c.....
	//...|*c*.....
	//suppose it matches before the seperator
	//
	// 1) if we don't update the star position, also means if we don't match the first 'c', also means we don't think this is the solution
	//    then we are looking for next 'c'
	//    ...|...c......c|.......
	//    ...|*c|*.....
	// 2) but if we update the star position, means we match the first 'c'
	//    ...|...c|......c.....
	//    ...|*c|*.....
	//
	//then we are searching solutions after the second seperators of the two strings
	//which covers the first case, because the second star can cover the second 'c', see below
	//and we will eventually come to this situation (the third seperator of the first string is the matchPos we iterate)
	//think in this way, we can treate '*' as "**"
	//    ...|...c|......c|.....
	//    ...|*c|*|*.....
	//
	//generally, if we don't update the first star position and have a solution,
	//update the star will reach the same
	bool isMatch(string s, string p) {
		int i = 0;
		int j = 0;
		int starPos = -1;
		int matchPos = -1;
		p += '#';
		while (i < s.size()) {
			if ((s[i] == p[j]) || (p[j] == '?')) { i++; j++; continue; }
			if (p[j] == '*') { starPos = j++; matchPos = i; continue; }
			if (starPos >= 0) { j = starPos + 1; i = ++matchPos; continue; }
			return false;
		}
		while (j < p.size() && p[j] == '*')
			j++;
		return j == p.size() - 1;
	}
};

class Solution44_01 {
public:
    bool isMatch(string s, string p) {
        int i = 0, j = 0;
        int star1 = s.size(), star2 = p.size();
        while(i < s.size() || j < p.size()) {
            if (j >= p.size()) {
                if (star2 < p.size() && star1 < int(s.size()))
                    i = star1++, j = star2;
                else return false;
            }
            else if (i >= s.size()) {
                int k = j;
                while(k < p.size() && (p[k] == '*')) k++;
                if (k == p.size()) return true;
                else if (star2 < p.size() && star1 < int(s.size()))
                    i = star1++, j = star2;
                else return false;
            }
            else if (p[j] == '*') star2 = j, star1 = i-- - 1;
			else if (s[i] != p[j] && p[j] != '?') {
                if (star2 < p.size() && star1 < int(s.size()))
                    i = star1++, j = star2;
                else return false;
            }
            i++, j++;
        }
        return true;
    }
};

class Solution44_02 {
public:
    bool isMatch(string s, string p) {
        int i = 0, j = 0;
        int star1 = -1, star2 = -1;
		p += '#';
        while(i < s.size()) {
            if (p[j] == '?' || s[i] == p[j]) {i++; j++; continue;}
            if (p[j] == '*') {star1 = i; star2 = j++; continue;}
            if (star2 >= 0) {i = ++star1; j = star2 + 1;}
            else return false;
        }
        while(j < p.size() - 1) {
            if (p[j] == '*') j++;
            else return false;
        }
        return true;
    }
};

class Solution45 {
public:
	int jump(vector<int>& nums) {
		int n = nums.size();
		vector<int> dp(n, -1);
		dp[n - 1] = 0;
		for (int i = n - 2; i >= 0; i--) {
			int minStep = -1;
			for (int j = 1; j <= nums[i] && i + j < n; j++) {
				if (dp[i + j] < 0) { continue; }
				minStep = (minStep < 0) ? dp[i + j] + 1 : min(minStep, dp[i + j] + 1);
			}
			dp[i] = (minStep < 0) ? -1 : minStep;
		}
		return dp[0];
	}
};
//Solution49 sln49;
//int num[] = { 2,3,1,1,4 };
//vector<int> nums(num, num + sizeof(num) / sizeof(int));
//vector<string> strs;
//strs.push_back("abc"); strs.push_back("cba"); strs.push_back("bac");
//strs.push_back("abf"); strs.push_back("fba"); strs.push_back("faa");
//vector<string> res = sln49.anagrams(strs);
/*
class Solution49 {
public:
	vector<string> anagrams(vector<string>& strs) {
		vector<string> copyStr(strs);
		unordered_map<string, vector<int>> mp;
		vector<string> res;
		for (int i = 0; i < copyStr.size(); i++) {
			sort(copyStr[i].begin(), copyStr[i].end());
			mp[copyStr[i]].push_back(i);
		}
		for (auto it: mp) {
			for (int i = 0; it.second.size() > 1 && i < it.second.size(); i++) {
				res.push_back(strs[it.second[i]]);
			}
		}
		return res;
	}
};
*/

class Solution50 {
public:
	double myPow(double x, int n) {


	}
};

//Solution54 sln54;
//vector<vector<int>> matrix;
//int num1[] = { 1, 2, 3 };
//vector<int> nums1(num1, num1 + sizeof(num1) / 4);
//int num2[] = { 4, 5, 6 };
//vector<int> nums2(num2, num2 + sizeof(num2) / 4);
//int num3[] = { 7, 8, 9 };
//vector<int> nums3(num3, num3 + sizeof(num3) / 4);
//matrix.push_back(nums1); matrix.push_back(nums2); matrix.push_back(nums3);
//vector<int> res = sln54.spiralOrder(matrix);

class Solution54 {
public:
	vector<int> spiralOrder(vector<vector<int>>& matrix) {
		vector<int> res;
		if (matrix.empty() || matrix[0].empty()) return res;
		int m = matrix.size(), n = matrix[0].size();
		int dirMap[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
		int k = 0;
		int board[4] = { -1, n, m, -1 };
		int boardShrink[4] = {1, -1, -1, 1};
		int x = 0, y = 0, newX = 0, newY = 0;
		while (board[3] < board[1] - 1 && board[0] < board[2] - 1) {
			res.push_back(matrix[x][y]);
			newX = x + dirMap[k][0]; newY = y + dirMap[k][1];
			if ((board[0] < newX) && (newX < board[2])
				&& (board[3] < newY) && (newY < board[1])) {
				x = newX; y = newY;
				continue;
			}
			board[k] += boardShrink[k];
			k = (k + 1) % 4;
			x = x + dirMap[k][0]; y = y + dirMap[k][1];
		}
		return res;
	}
};

class Solution56 {
public:
	vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {
		vector<Interval> res;
		vector<Interval>::iterator it = intervals.begin();
		while (it != intervals.end()) {
			if (it->end < newInterval.start) { res.push_back(*it); it++; continue; }
			else if (it->start > newInterval.end) { break; }
			else {
				newInterval.start = min(newInterval.start, it->start);
				newInterval.end = max(newInterval.end, it->end);
				it++;
			}
		}
		/*
		res.push_back(newInterval);
		while (it != intervals.end()) {
			res.push_back(*it++);
		}
		*/
		res.insert(res.end(), it, intervals.end());
		return res;
	}
};

//LTE
class Solution56_01 {
public:
	vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {
		vector<Interval>::iterator it = intervals.begin();
		while (it != intervals.end()) {
			if (newInterval.end < it->start) {
				intervals.insert(it, newInterval);
				return intervals;
			}
			else if (newInterval.start > it->end) {
				it++;
				continue;
			}
			else {
				newInterval.start = min(newInterval.start, it->start);
				newInterval.end = max(newInterval.end, it->end);
				it = intervals.erase(it);
			}
		}
		intervals.insert(intervals.end(), newInterval);
		return intervals;
	}
};

class Solution57 {
public:
	struct comp {
		bool operator() (Interval intv1, Interval intv2) {
			return (intv1.start < intv2.start) || ((intv1.start == intv2.start) && (intv1.end < intv2.end));
		}
	};
	static bool comp (Interval intv1, Interval intv2) {
		return (intv1.start < intv2.start) || ((intv1.start == intv2.start) && (intv1.end < intv2.end));
	}
	vector<Interval> merge(vector<Interval>& intervals) {
		vector<Interval> res;
		if (intervals.empty()) { return res; }
		sort(intervals.begin(), intervals.end(), comp);
		Interval curIntv = intervals[0];
		for (int i = 1; i < intervals.size(); i++) {
			if (curIntv.end < intervals[i].start) { res.push_back(curIntv); curIntv = intervals[i]; continue; }
			curIntv.end = max(curIntv.end, intervals[i].end);
		}
		res.push_back(curIntv);
		return res;
	}
};

class Solution58 {
public:
	int lengthOfLastWord(string s) {
		auto last = s.find_last_not_of(' ');
		if (last != string::npos) { s.erase(last + 1, s.size() - last - 1); }
		else return 0;
		last = s.find_last_of(' ');
		return (last==string::npos) ? s.size() : s.size() - last - 1;
	}
};

class Solution59 {
public:
	vector<vector<int>> generateMatrix(int n) {
		vector<vector<int>> res;
		for (int i = 0; i < n; i++) {
			res.push_back(vector<int>(n, 0));
		}
		int dirMap[4][2] = { 0, 1, 1, 0, 0, -1, -1, 0 };
		int k = 0;
		int board[4] = { -1, n, n, -1 };
		int boardShrink[4] = { 1, -1, -1, 1 };
		int x = 0, y = 0, newX = 0, newY = 0;
		int d = 1;
		while (board[3] < board[1] - 1 && board[0] < board[2] - 1) {
			res[x][y] = d++;
			newX = x + dirMap[k][0]; newY = y + dirMap[k][1];
			if ((board[0] < newX) && (newX < board[2])
				&& (board[3] < newY) && (newY < board[1])) {
				x = newX; y = newY;
				continue;
			}
			board[k] += boardShrink[k];
			k = (k + 1) % 4;
			x = x + dirMap[k][0]; y = y + dirMap[k][1];
		}
		return res;
	}
};

class Solution59_01 {
public:
	vector<vector<int>> generateMatrix(int n) {
		vector<vector<int>> res(n, vector<int>(n, 0));
		int rowStart = 0, rowEnd = n - 1;
		int colStart = 0, colEnd = n - 1;
		int k = 1;
		while (rowStart <= rowEnd && colStart <= colEnd) {
			for (int i = colStart; i <= colEnd; i++)
				res[rowStart][i] = k++;
			rowStart++;
			for (int i = rowStart; i <= rowEnd; i++)
				res[i][colEnd] = k++;
			colEnd--;
			for (int i = colEnd; i >= colStart; i--)
				res[rowEnd][i] = k++;
			rowEnd--;
			for (int i = rowEnd; i >= rowStart; i--)
				res[i][colStart] = k++;
			colStart++;;
		}
		return res;
	}
};

//Solution60_01 sln60;
//string res = sln60.getPermutation(3, 4);
class Solution60 {
public:
	string getPermutation(int n, int k) {
		string res;
		vector<char> vec(n, ' ');
		for (int i = 0; i < n; i++) {
			vec[i] = '0' + i + 1;
		}
		while (--k > 0) {
			next_permutation(vec.begin(), vec.end());
		}
		for (int i = 0; i < n; i++) {
			res += vec[i];
		}
		return res;
	}
};

class Solution60_01 {
public:
	int factorial(int n) {
		if (n <= 2) return n;
		return n * factorial(n - 1);
	}
	string getPermutation(int n, int k) {
		string res;
		vector<char> digits;
		for (int i = 1; i <= n; i++) {
			digits.push_back('0' + i);
		}
		int nFactorial = factorial(n - 1);
		k--;
		for (int i = 0; i < n - 1; i++) {
			int pos = k / nFactorial;
			res += digits[pos];
			digits.erase(digits.begin() + pos);
			k = k % nFactorial;
			nFactorial /= n - i - 1;
		}
		res += digits[0];
		return res;
	}
};

class Solution60_02 {
public:
    string getPermutation(int n, int k) {
        vector<char> digits;
        string res = "";
        int fac = 1;
        for(int i = 1; i <= n - 1; i++){
            digits.push_back('0' + i);
            fac *= i;
        }
        digits.push_back('0' + n);
        
        int t = n - 1;
        while (k > 1) {
            int index = (k - 1) / fac;
            res += digits[index];
            digits.erase(digits.begin() + index);
            k -= index * fac;
            fac = int(fac / t--);
        }
        
        for(int i = 0; i <  digits.size(); i++){
            res += digits[i];
        }
        return res;
    }
};


//ListNode *head = new ListNode(1);
//head->next = new ListNode(2);
//head->next->next = new ListNode(3);
//head->next->next->next = new ListNode(4);
//head->next->next->next->next = new ListNode(5);
//ListNode *res = sln61.rotateRight(head, 7);
//12ms
class Solution61 {
public:
	ListNode* rotateRight(ListNode* head, int k) {
		if (!head) return 0;
		ListNode **front = &head, **tail = front;
		int length = 0;
		while (*tail) {
			length++;
			tail = &((*tail)->next);
		}
		tail = front;
		k %= length;
		while (k-- > 0) {
			if (!*tail) tail = &head;
			tail = &((*tail)->next); 
		}
		while (*tail) {
			front = &((*front)->next);
			tail = &((*tail)->next);
		}
		*tail = head;
		head = *front;
		*front = NULL;
		return head;
	}
};

//8ms 
class Solution61_01 {
public:
	ListNode* rotateRight(ListNode* head, int k) {
		if (!head) return 0;
		ListNode **newH = &head, **p = &head;
		int len = 0;
		while (*p) {
			p = &((*p)->next);
			len++;
		}
		*p = head;
		k %= len;
		for (int i = 0; i < len - k; i++) {
			newH = &((*newH)->next);
		}
		head = *newH;
		*newH = NULL;
		return head;
	}
};

class Solution62 {
public:
	int uniquePaths(int m, int n) {
		vector<vector<int>> dp(m, vector<int>(n, 0));
		for (int i = 0; i < m; i++) { dp[i][n - 1] = 1; }
		for (int i = 0; i < n; i++) { dp[m - 1][i] = 1; }
		for (int i = m - 2; i >= 0; i--) {
			for (int j = n - 2; j >= 0; j--) {
				dp[i][j] = dp[i + 1][j] + dp[i][j + 1];
			}
		}
		return dp[0][0];
	}
};

class Solution62_02 {
public:
	int uniquePaths(int m, int n) {
		double res = 1;
		for (int i = 1; i <= m - 1; i++)
			res = res * (n - 1 + i) / i;
		return (int)res;
	}
};

class Solution63 {
public:
	int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
		if (obstacleGrid.empty()) return 0; 
		int m = obstacleGrid.size();
		int n = obstacleGrid[0].size();
		if (obstacleGrid[0][0] == 1 || obstacleGrid[m - 1][n - 1] == 1) return 0;
		vector<int> dp(n, 0);
		dp[n - 1] = 1;
		for (int i = m - 1; i >= 0; i--) {
			if ((dp[n - 1] == 1) && (obstacleGrid[i][n - 1] == 1)) dp[n - 1] = 0;
			for (int j = n - 2; j >= 0; j--) {
				dp[j] = (obstacleGrid[i][j] == 1) ? 0 : dp[j] + dp[j + 1];
			}
		}
		return dp[0];
	}
};

class Solution63_02 {
public:
	int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
		if (obstacleGrid.empty()) return 0;
		int m = obstacleGrid.size();
		int n = obstacleGrid[0].size();
		vector<int> dp(n + 1, 0);
		dp[n - 1] = 1;
		for (int i = m - 1; i >= 0; i--) {
			for (int j = n - 1; j >= 0; j--) {
				dp[j] = (obstacleGrid[i][j] == 1) ? 0 : dp[j] + dp[j + 1];
			}
		}
		return dp[0];
	}
};

class Solution64 {
public:
	int minPathSum(vector<vector<int>>& grid) {
		if (grid.empty()) return 0;
		int m = grid.size();
		int n = grid[0].size();
		vector<int> dp(n + 1, INT_MAX);
		dp[n - 1] = 0;
		for (int i = m - 1; i >= 0; i--) {
			for(int j = n - 1; j >= 0; j--) {
				dp[j] = min(dp[j], dp[j + 1]) + grid[i][j];
			}
		}
		return dp[0];
	}
};
//  http://postimg.org/image/btkjz1wdl/full/
class Solution65 {
public:
	bool isNumber(string s) {
		while (!s.empty() && s[0] == ' ') s.erase(s.begin());
		while (!s.empty() && s[s.size() - 1] == ' ') s.erase(s.end() - 1);
		if (s.empty()) return false;
		int state = 0;
		for (int i = 0; i < s.size(); i++) {
			if (s[i] == '+' || s[i] == '-') {
				if (state == 0) state = 1;
				else if (state == 3) state = 4;
				else return false;
			}
			else if (s[i] == '.') {
				if (state == 0) state = 6;
				else if (state == 1) state = 6;
				else if (state == 2) state = 7;
				else return false;
			}
			else if (s[i] >= '0' && s[i] <= '9') {
				if (state == 0) state = 2;
				else if (state == 1) state = 2;
				else if (state == 2) state = 2;
				else if (state == 6) state = 7;
				else if (state == 7) state = 7;
				else if (state == 3) state = 5;
				else if (state == 4) state = 5;
				else if (state == 5) state = 5;
				else return false;
			}
			else if (s[i] == 'e' || s[i] == 'E') {
				if (state == 2) state = 3;
				else if (state == 7) state = 3;
				else return false;
			}
			else return false;
		}
		return (state == 2 || state == 5 || state == 7);
	}
};

class Solution66 {
public:
	vector<int> plusOne(vector<int>& digits) {
		int carry = 0;
		int k = digits.size() - 2;
		carry = (digits[digits.size() - 1] + 1) / 10;
		digits[digits.size() - 1] = (digits[digits.size() - 1] + 1) % 10;
		while (carry && k >= 0){
			digits[k] = digits[k] + carry;
			carry = digits[k] / 10;
			digits[k] = digits[k] % 10;
			k--;
		}
		if (carry) {
			digits.insert(digits.begin(), 1);
		}
		return digits;
	}
};

class Solution66_01 {
public:
    vector<int> plusOne(vector<int>& digits) {
        int c = 1;
        for(int i = (int)digits.size() - 1; i >= 0; i--) {
            c += digits[i];
            digits[i] = c % 10;
            c = int(c / 10);
        }
        if (c) digits.insert(digits.begin(), 1);
        return digits;
    }
};

class Solution66_02 {
public:
	vector<int> plusOne(vector<int>& digits) {
		int n = digits.size();
		for (int i = n - 1; i >= 0; --i)
		{
			if (digits[i] == 9) digits[i] = 0;
			else{
				digits[i]++;
				return digits;
			}
		}
		digits[0] = 1;
		digits.push_back(0);
		return digits;
	}
};

class Solution66_03 {
public:
    vector<int> plusOne(vector<int>& digits) {
        int k = (int)digits.size() - 1;
        while(k >= 0 && digits[k] == 9) {
            digits[k--] = 0;
        }
        if (k >= 0) digits[k]++;
        else digits.insert(digits.begin(), 1);
        return digits;
    }
};

class Solution67 {
public:
	string addBinary(string a, string b) {
		string res(max(a.size(), b.size()), ' ');
		if (a.size() < b.size()) swap(a, b);
		int carry = 0;
		int pa = a.size() - 1, pb = b.size() - 1;
		while (pa >= 0) {
			int temp = (a[pa] - '0') + carry;
			temp += (pb >= 0) ? (b[pb] - '0') : 0;
			carry = temp / 2;
			res[pa] = '0' + (temp % 2);
			pa--; pb--;
			
		}
		if (carry) res.insert(res.begin(), '1');
		return res;
	}
};

class Solution67_02 {
public:
	string addBinary(string a, string b) {
		string res = "";
		int i = a.size() - 1, j = b.size() - 1;
		int c = 0;
		while (i >= 0 || j >= 0 || c > 0) {
			c += (i >= 0) ? a[i--] - '0' : 0;
			c += (j >= 0) ? b[j--] - '0' : 0;
			res = char('0' + c % 2) + res;
			c = c / 2;
		}
		return res;
	}
};

class Solution68 {
public:
	int mySqrt(int x) {
		if (x < 2) return x;
		int l = 1, r = x;
		while (l < r - 1) {
			int mid = l + (r - l) / 2, temp = x / mid;
			if (temp == mid) return mid;
			else if (temp > mid) l = mid;
			else r = mid;
		}
		return l;
	}
};

class Solution68_02 {
public:
	int mySqrt(int x) {
		int ans = 0;
		long long bit = 1 << 15;
		while (bit > 0) {
			ans |= bit;
			if (x / ans < ans) {
				ans ^= bit;
			}
			bit >>= 1;
		}
		return int(ans);
	}
};

class Solution69 {
public:
	int climbStairs(int n) {
		if (n == 0) return 0;
		if (n == 1) return 1;
		if (n == 2) return 2;
		int a = 1, b = 2;
		for (int i = 0; i < n - 2; i++) {
			int temp = a + b;
			a = b;
			b = temp;
		}
		return b;
	}
};

class Solution69_02 {
public:
    int climbStairs(int n) {
        if (n <= 2) return n;
        int f1 = 1, f2 = 2;
        while(n-- > 2) {
            f1 = f1 + f2;
            swap(f1, f2);
        }
        return f2;
    }
};

class Solution70 {
public:
	string simplifyPath(string path) {
		string res;
		stack<string> stk;
		string folder = "";
		path += '/';
		for (int i = 0; i < path.size(); i++) {
			if (path[i] == '/') {
				if (folder == "..") {if (!stk.empty()) stk.pop(); }
				else if (!folder.empty() && folder != ".") { stk.push(folder); };
				folder.clear();
			}
			else {
				folder.push_back(path[i]);
			}
		}
		if (stk.empty()) return "/";
		while (!stk.empty()) {
			res = '/' + stk.top() + res;
			stk.pop();
		}
		return res;
	}
};

/*
class Solution70_02 {
public:
	string simplifyPath(string path) {
		string res;
		stack<string> stk;
		string folder = "";
		stringstream ss(path);
		string tmp;
		while (getline(ss, tmp, '/')) {
			if (tmp == ".") continue;
			if (tmp == "..") { if (!stk.empty()) stk.pop(); }
			else if (!tmp.empty()) stk.push(tmp);
		}
		if (stk.empty()) return "/";
		while (!stk.empty()) {
			res = '/' + stk.top() + res;
			stk.pop();
		}
		return res;
	}
};
*/

class Solution72 {
public:
	int minDistance(string word1, string word2) {
		int l1 = word1.size(), l2 = word2.size();
		vector<vector<int>> dp(l1 + 1, vector<int>(l2 + 1, 0));
		for (int i = 1; i <= l1; i++) {
			dp[i][0] = i;
		}
		for (int i = 1; i <= l2; i++) {
			dp[0][i] = i;
		}
		for (int i = 1; i <= l1; i++) {
			for (int j = 1; j <= l2; j++) {
				int tmpCost = (word1[i - 1] == word2[j - 1]) ? 0 : 1;
				dp[i][j] = min(dp[i - 1][j - 1] + tmpCost, min(dp[i][j - 1], dp[i - 1][j]) + 1);
			}
		}
		return dp[l1][l2];
	}
};

class Solution72_02 {
public:
	int minDistance(string word1, string word2) {
		int l1 = word1.size(), l2 = word2.size();
		vector<int> dp(l2 + 1, INT_MAX);
		for (int i = 0; i <= l2; i++)
			dp[i] = i;
		for (int i = 1; i <= l1; i++) {
			int pre = i - 1;
			dp[0] = i;
			for (int j = 1; j <= l2; j++) {
				int cur = dp[j];
				int cost = (word1[i - 1] == word2[j - 1]) ? 0 : 1;
				dp[j] = min(min(dp[j - 1], dp[j]) + 1, pre + cost);
				pre = cur;
			}
		}
		return dp[l2];
	}
};

class Solution73 {
public:
	void setZeroes(vector<vector<int>>& matrix) {
		if (matrix.empty()) return;
		int m = matrix.size(), n = matrix[0].size();
		vector<bool> row(m, false);
		vector<bool> col(n, false);
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				if (matrix[i][j] == 0)
					row[i] = col[j] = true;
			}
		}
		for (int i = 0; i < m; i++) {
			if (row[i]) {
				fill(matrix[i].begin(), matrix[i].end(), 0);
			}
		}
		for (int j = 0; j < n; j++) {
			if (col[j]) {
				for (int i = 0; i < m; i++) {
					matrix[i][j] = 0;
				}
			}
		}
	}
};

class Solution73_02 {
public:
	void setZeroes(vector<vector<int>>& matrix) {
		if (matrix.empty()) return;
		int m = matrix.size(), n = matrix[0].size();
		bool rowZero = false, colZero = false;
		for (int i = 0; i < n; i++) {
			if (matrix[0][i] == 0) {
				rowZero = true;
				break;
			}
		}
		for (int i = 0; i < m; i++) {
			if (matrix[i][0] == 0) {
				colZero = true;
				break;
			}
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (matrix[i][j] == 0) {
					matrix[0][j] = matrix[i][0] = 0;
				}
			}
		}
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (matrix[0][j] == 0 || matrix[i][0] == 0) {
					matrix[i][j] = 0;
				}
			}
		}
		if (rowZero) {
			for (int i = 0; i < n; i++) matrix[0][i] = 0;
		}
		if (colZero) {
			for (int i = 0; i < m; i++) matrix[i][0] = 0;
		}
	}
};

//even smarter
class Solution73_03 {
public:
	void setZeroes(vector<vector<int>>& matrix) {
		int m = matrix.size(), n = matrix[0].size();
		bool colZero = false;
		for (int i = 0; i < m; i++) {
			if (matrix[i][0] == 0) colZero = true;
			for (int j = 1; j < n; j++) {
				if (matrix[i][j] == 0)
					matrix[i][0] = matrix[0][j] = 0;
			}
		}
		for (int i = m - 1; i >= 0; i--) {
			for (int j = n - 1; j >= 1; j--) {
				if (matrix[i][0] == 0 || matrix[0][j] == 0)
					matrix[i][j] = 0;
			}
			if (colZero) {
				matrix[i][0] = 0;
			}
		}
	}
};


//vector<vector<int>> matrix(3, vector<int>(4, 0));
//matrix[0][0] = 1; matrix[0][1] = 3; matrix[0][2] = 5; matrix[0][3] = 7;
//matrix[1][0] = 10; matrix[1][1] = 11; matrix[1][2] = 16; matrix[1][3] = 20;
//matrix[2][0] = 23; matrix[2][1] = 30; matrix[2][2] = 34; matrix[2][3] = 50;

class Solution74_03 {
public:
	bool searchMatrix(vector<vector<int>>& matrix, int target) {
		if (matrix.empty()) return false;
		int m = matrix.size(), n = matrix[0].size();
		int rowL = 0, colL = 0, rowR = m - 1, colR = n - 1;
		while (rowL < rowR || (rowL == rowR && colL < colR)) {
			int diff = (rowR - rowL) * n + colR - colL;
			int midRow = (rowL * n + colL + diff / 2) / n, midCol = (rowL * n + colL + diff / 2) % n;
			int tmp = matrix[midRow][midCol];
			if (tmp == target) return true;
			if (tmp > target) {
				midCol--;
				if (midCol == 0) { midRow--; midCol = n - 1;}
				rowR = midRow; colR = midCol;
			}
			else { 
				midCol++;
				if (midCol >= n) { midRow++; midCol = 0; }
				rowL = midRow; colL = midCol; 
			}
		}
		return false;
	}
};

/*
class Solution78 {
public:
	vector<vector<int>> subsets(vector<int>& nums) {
		//bit manipulation
		vector<vector<int>> res;
		vector<int> sln;
		sort(nums.begin(), nums.end());
		int n = nums.size();
		int total = pow(2, n);
		for (int i = 0; i < total; i++) {
			sln.clear();
			for (int j = 0; j < n; j++) {
				if (i >> j & 1)
					sln.push_back(nums[j]);
			}
			res.push_back(sln);
		}
		return res;
	}
};
*/

class Solution78_02 {
public:
	vector<vector<int>> subsets(vector<int>& nums) {
		//iterative
		vector<vector<int>> res;
		sort(nums.begin(), nums.end());
		int n = nums.size();
		res.push_back(vector<int>(0, 0));
		for (int i = 0; i < n; i++) {
			int resSize = res.size();
			for (int j = 0; j < resSize; j++) {
				res.push_back(res[j]);
				res.back().push_back(nums[i]);
			}
		}
		return res;
	}
};

class Solution78_03 {
public:
	vector<vector<int>> subsets(vector<int>& nums) {
		//Interesting way to use the bit masks, building all subsets in parallel. I don't think I've seen that before. Made me write a way to "only iterate over the 1-bits":
		//https://leetcode.com/discuss/46668/recursive-iterative-manipulation-solutions-explanations
		//don't understand
		/*
        for (int i = 0; i < nums.size(); i++)
		    for (int step = 1 << i, start = 0; start < num_subset; start += 2 * step)
		    	for (int j = start; j < start + step; j++)
				    res[j].push_back(nums[i]);
	    */
	}
};

//vector<vector<char>> board(3, vector<char>(3, 'a'));
//board[0][0] = 'C'; board[0][1] = 'A'; board[0][2] = 'A';
//board[1][0] = 'A'; board[1][1] = 'A'; board[1][2] = 'A';
//board[2][0] = 'B'; board[2][1] = 'C'; board[2][2] = 'D';
//bool res = sln79.exist(board, "AAB");

class Solution79 {
public:
	bool dfs(vector<vector<char>>& board, string& word, vector<vector<bool>>& aval, int x, int y, int k) {
		if (k >= word.size()) { return true; }
		int dir[4][2] = {-1, 0, 0, 1, 1, 0, 0, -1};
		bool found = false;
		for (int i = 0; i < 4; i++) {
			int xx = x + dir[i][0], yy = y + dir[i][1];
			if (xx >= 0 && xx < board.size() && yy >= 0 && yy < board[0].size() && aval[xx][yy] && board[xx][yy] == word[k]) {
				aval[xx][yy] = false;
				found = dfs(board, word, aval, xx, yy, k + 1);
				if (found) return true;
				aval[xx][yy] = true;
			}
		}
		return found;
	}
	bool exist(vector<vector<char>>& board, string word) {
		if (board.empty()) {
			return word.empty() ? true : false;
		}
		int m = board.size(), n = board[0].size();
		vector<vector<bool>> aval(m, vector<bool>(n, true)); //consider using board[row][col] = '*';
		int dir[4][2] = { -1, 0, 0, 1, 1, 0, 0, -1 };
		bool found = false;
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				if (board[i][j] == word[0]) {
					aval[i][j] = false;
					found = dfs(board, word, aval, i, j, 1);
					if (found) return true;
					aval[i][j] = true;
				}
			}
		}
		return false;
	}
};

class Solution80 {
public:
	int removeDuplicates(vector<int>& nums) {
		int offset = 0, counts = 0;
		for (int i = 1; i < nums.size(); i++) {
			if (nums[i] == nums[i - 1]) {
				counts++;
				if (counts > 1) offset++;
			}
			else {
				counts = 0;
			}
			nums[i - offset] = nums[i];
		}
		return nums.size() - offset;
	}
};

class Solution80_02 {
public:
	int removeDuplicates(vector<int>& nums) {
		if (nums.size() < 2) return nums.size();
		int k = 1;
		for (int i = 2; i < nums.size(); i++) {
			if (nums[i] != nums[k - 1]) nums[++k] = nums[i];
		}
		return k + 1;
	}
};

class Solution81 {
public:
	bool search(vector<int>& nums, int target) {
		if (nums.empty()) return false;
		int l = 0, r = nums.size() - 1;
		while (l <= r) {
			int m = (l + r) / 2;
			if (nums[m] == target) return true;
			if (nums[l] < nums[m]){
				if (nums[l] <= target && target < nums[m]) r = m - 1;
				else l = m + 1;
			}
			else if (nums[l] > nums[m]) {
				if (nums[m] < target && target <= nums[r]) l = m + 1;
				else r = m - 1;
			}
			else l++;
		}
		return false;
	}
};

class Solution82_03 {
public:
	ListNode* deleteDuplicates(ListNode* head) {
		if (!head) return NULL;
		ListNode **it = &head, **front;
		int m = head->val - 1;
		while (*it) {
			if ((*it)->val == m){
				*it = (*it)->next;
			}
			else {
				if (!front) continue;
				*front = *it;
				front = it;
				m = (*it)->val;
				it = &((*it)->next);
			}
		}
		return head;
	}
};

class Solution83_03 {
public:
	ListNode* deleteDuplicates(ListNode* head) {
		if (!head) return NULL;
		ListNode *p = head;
		while (p->next) {
			if (p->next->val == p->val) p->next = p->next->next;
			else p = p->next;
		}
		return head;
	}
};

class Solution83_04 {
public:
	ListNode* deleteDuplicates(ListNode* head) {
		return (head && (head->next = deleteDuplicates(head->next)) && head->val == head->next->val) ? head->next : head;
	}
};

class Solution84 {
public:
    int largestRectangleArea(vector<int>& height) {
        if (height.empty()) return 0;
        int res = 0;
        stack<int> stk;
        for(int i = 0; i < height.size(); i++) {
            if (stk.empty() || height[i] >= height[stk.top()]) stk.push(i);
            else {
				int temp = stk.top();
				stk.pop();
				if (stk.empty()) res = max(res, height[temp] * i);
                else res = max(res, height[temp] * (i - stk.top() - 1)); 
				i--;
            }
        }
        int temp;
        while(!stk.empty()) {
            temp = stk.top();
		    stk.pop();
			if (stk.empty()) res = max(res, height[temp] * int(height.size()));
            else res = max(res, height[temp] * (int(height.size()) - stk.top() - 1)); 
        }
        res = max(res, height[temp] * int(height.size()));
        return res;
    }
};

class Solution84_02 {
public:
    int largestRectangleArea(vector<int>& height) {
        if (height.empty()) return 0;
        int res = 0;
        stack<int> stk;
        int i = 0;
        while(!stk.empty() || i < height.size()) {
            if (i < height.size() && (stk.empty() || height[i] >= height[stk.top()])) stk.push(i++);
            else {
                int temp = stk.top();
                stk.pop();
                if (stk.empty()) res = max(res, height[temp] * i);
                else res = max(res, height[temp] * (i - stk.top() - 1));
            }
        }
        return res;
    }
};

class Solution85 {
public:
	int maximalRectangle(vector<vector<char>>& matrix) {
		if (matrix.empty()) return 0;
		int res;
		int m = matrix.size(), n = matrix[0].size();
		vector<int> height(n, 0), left(n, 0), right(n, n);
		for (int i = 0; i < m; i++) {
			int leftMost = 0, rightMost = n - 1;
			for (int j = 0; j < n; j++) {
				if (matrix[i][j] == '1') height[j]++;
				else height[j] = 0;
			}
			for (int j = 0; j < n; j++) {
				if (matrix[i][j] == '0') { leftMost = j + 1; left[j] = 0; }
				else { left[j] = max(left[j], leftMost); }
			}

			for (int j = n - 1; j >=0; j--) {
				if (matrix[i][j] == '0') { rightMost = j - 1; right[j] = n - 1; }
				else { right[j] = min(right[j], rightMost); }
			}

			for (int j = 0; j < n; j++) {
				res = max(res, height[j] * (right[j] - left[j] + 1));
			}
		}
		return res;
	}
};

//ListNode *head = new ListNode(1);
//head->next = new ListNode(4);
//head->next->next = new ListNode(3);
//head->next->next->next = new ListNode(2);
//head->next->next->next->next = new ListNode(5);
//head->next->next->next->next->next = new ListNode(2);
//ListNode *res = sln86.partition(head, 3);

class Solution86 {
public:
	ListNode* partition(ListNode* head, int x) {
		ListNode *pL = NULL, *pR = NULL, *pLH = NULL, *pRH = NULL, *p = head;
		while (p) {
			if (p->val < x) {
				if (!pL) { pLH = pL = p; }
				else { pL->next = p; pL = p; }
			}
			else {
				if (!pR) { pRH = pR = p; }
				else { pR->next = p; pR = p; }
			}
			p = p->next;
		}
		if (pR) { pR->next = NULL; }
		if (!pLH) return pRH;
		pL->next = pRH;
		return pLH;
	}
};

class Solution86_02 {
public:
	ListNode* partition(ListNode* head, int x) {
		ListNode node1(0), node2(0);
		ListNode *p1 = &node1, *p2 = &node2;
		while (head) {
			if (head->val < x) {
				p1 = p1->next = head;
			}
			else {
				p2 = p2->next = head;
			}
			head = head->next;
		}
		p2->next = NULL;
		p1->next = node2.next;
		return node1.next;
	}
};

//24ms
class Solution87 {
public:
	bool isScramble(string s1, string s2) {
		if (s1.size() != s2.size()) return false;
		int n = s1.size();
		bool*** dp = new bool**[n];
		for (int i = 0; i < n; i++) {
			dp[i] = new bool*[n];
			for (int j = 0; j < n; j++) {
				dp[i][j] = new bool[n + 1];
			}
		}
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				dp[i][j][1] = s1[i] == s2[j];
			}
		}
		for (int l = 2; l <= n; l++) {
			for (int i = 0; i <= n - l; i++) {
				for (int j = 0; j <= n - l; j++) {
					for (int k = 1; k <= l - 1 && !dp[i][j][l]; k++) {
						dp[i][j][l] = (dp[i][j][k] && dp[i + k][j + k][l - k])
							|| (dp[i][j + l - k][k] && dp[i + k][j][l - k]);
					}
				}
			}
		}
		return dp[0][0][n];
	}
};

//4ms
class Solution87_02 {
public:
	bool helper(string &s1, string &s2, int p1, int p2, int l) {
		if (l == 1)
			return s1[p1] == s2[p2];
		bool flag = false;
		int count[26];
		fill_n(count, 26, 0);
		for (int i = 0; i < l; i++) {
			count[s1[p1 + i] - 'a']++;
			count[s2[p2 + i] - 'a']--;
		}
		for (int i = 0; i < 26; i++) {
			if (count[i] != 0)
				return false;
		}

		for (int k = 1; k <= l - 1 && !flag; k++) {
			flag = (helper(s1, s2, p1, p2, k) && helper(s1, s2, p1 + k, p2 + k, l - k))
				|| (helper(s1, s2, p1, p2 + l - k, k) && helper(s1, s2, p1 + k, p2, l - k));
		}
		return flag;
	}
	bool isScramble(string s1, string s2) {
		if (s1.size() != s2.size()) return false;
		return helper(s1, s2, 0, 0, s1.size());
	}
};

/*
//get compile error locally
//8ms
class Solution87_03 {
public:
	bool helper(string &s1, string &s2, int*** cache, int p1, int p2, int l) {
		if (l == 1)
			return s1[p1] == s2[p2];
		if (cache[p1][p2][l] != -1)
			return cache[p1][p2][l];
		bool flag = false;
		int count[26];
		fill_n(count, 26, 0);
		for (int i = 0; i < l; i++) {
			count[s1[p1 + i] - 'a']++;
			count[s2[p2 + i] - 'a']--;
		}
		for (int i = 0; i < 26; i++) {
			if (count[i] != 0)
				return false;
		}

		for (int k = 1; k <= l - 1 && !flag; k++) {
			flag = (helper(s1, s2, cache, p1, p2, k) && helper(s1, s2, cache, p1 + k, p2 + k, l - k))
				|| (helper(s1, s2, cache, p1, p2 + l - k, k) && helper(s1, s2, cache, p1 + k, p2, l - k));
		}
		if (cache[p1][p2][l] == -1)
			cache[p1][p2][l] = flag ? 1 : 0;
		return flag;
	}
	bool isScramble(string s1, string s2) {
		if (s1.size() != s2.size()) return false;
		int n = s1.size();
		int*** cache = new int**[n];
		for (int i = 0; i < n; i++) {
			cache[i] = new int*[n];
			for (int j = 0; j < n; j++) {
				cache[i][j] = new int[n + 1];
				fill_n(cache[i][j], n + 1, -1);
			}
		}
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				cache[i][j][1] = (s1[i] == s2[j]) ? 1 : 0;
			}
		}
		return helper(s1, s2, cache, 0, 0, s1.size());
	}
};
*/

class Solution88 {
public:
	void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
		int p1 = m - 1, p2 = n - 1;
		while (p1 >= 0 && p2 >= 0) {
			if (nums2[p2] >= nums1[p1]) {
				nums1[p1 + p2 + 1] = nums2[p2--];
			}
			else nums1[p1 + p2] = nums1[p1--];
		}
		while (p2 >= 0) {
			nums1[p2] = nums2[p2--];
		}
	}
};

class Solution88_02 {
public:
	void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
		int p1 = m - 1, p2 = n - 1;
		while (p2 >= 0) {
			if (p1 < 0 || nums1[p1] <= nums2[p2])
				nums1[p1 + p2 + 1] = nums2[p2--];
			else nums1[p1 + p2 + 1] = nums1[p1--];
		}
	}
};

/*
class Solution89{
public:
	void dfs(vector<int> &res, vector<bool> &aval, int n, int code, int &sum, int target) {
		if (sum == target)
			return;
		for (int i = 0; i < n; i++) {
			if (aval[code ^ (1 << i)]) {
				code = code ^ (1 << i);
				aval[code] = false;
				res.push_back(code);
				dfs(res, aval, n, code, ++sum, target);
			}
		}
	}
	vector<int> grayCode(int n) {
		vector<int> res(1, 0);
		vector<bool> aval(pow(2, n), true);
		aval[0] = false;
		int sum = 0;
		dfs(res, aval, n, 0, sum, pow(2, n));
		return res;
	}
};
*/
/*
class Solution89_02 {
public:
	vector<int> grayCode(int n) {
		vector<int> res;
		for (int i = 0; i < pow(2, n); i++)
			res.push_back(i ^ (i >> 1));
		return res;
	}
};
*/

//smart
//https://leetcode.com/discuss/1525/what-if-i-have-no-knowledge-over-gray-code-before
class Solution89_03 {
public:
	vector<int> grayCode(int n) {
		vector<int> res;
		res.push_back(0);
		for (int i = 1; i <= n; i++) {
			for (int k = res.size() - 1; k >= 0; k--) {
				res.push_back(res[k] | (1 << (i - 1)));
			}
		}
		return res;
	}
};

//20ms
class Solution90 {
public:
	vector<vector<int>> subsetsWithDup(vector<int>& nums) {
		set<vector<int>> res;
		sort(nums.begin(), nums.end());
		int n = nums.size();
		vector<int> vec;
		for (int i = 0; i < 1 << n; i++) {
			vec.clear();
			for (int j = 0; j < n; j++) {
				if ((i >> j) & 1)
					vec.push_back(nums[j]);
			}
			res.insert(vec);
		}
		return vector<vector<int>>(res.begin(), res.end());
	}
};

//12ms
class Solution90_02 {
public:
	vector<vector<int>> subsetsWithDup(vector<int>& nums) {
		vector<vector<int>> res(1);
		sort(nums.begin(), nums.end());
		int n = nums.size();
		int bar = 0;
		for (int i = 0; i < n; i++) {
			int l = res.size();
			for (int j = 0; j < l; j++) {
				if (i == 0 || nums[i] != nums[i - 1] || j >= bar) {
					res.push_back(res[j]);
					res.back().push_back(nums[i]);
				}
			}
			bar = l;
		}
		return res;
	}
};

//12ms
class Solution90_03 {
public:
	vector<vector<int>> subsetsWithDup(vector<int>& nums) {
		vector<vector<int>> res(1);
		sort(nums.begin(), nums.end());
		int n = nums.size(), k = 0;
		while (k < n) {
			int count = 1;
			while (k + 1 < n && nums[k + 1] == nums[k]) {
				k++; count++;
			}
			int l = res.size();
			vector<int> tmp;
			for (int c = 0; c < count; c++) {
				tmp.push_back(nums[k]);
				for (int j = 0; j < l; j++) {
					res.push_back(res[j]);
					res.back().insert(res.back().end(), tmp.begin(), tmp.end());
				}
			}
			k++;
		}
		return res;
	}
};

//12ms
class Solution90_04 {
public:
	vector<vector<int>> subsetsWithDup(vector<int>& nums) {
		vector<vector<int>> ret;
		ret.push_back(vector<int>());
		sort(nums.begin(), nums.end());
		for (int i = 0; i < nums.size(); ) {
			int j = i;
			while (j < nums.size() && nums[j] == nums[i]) j++;
			int size = ret.size();
			vector<int> tmp;
			for (int len = 1; i + len <= j; len++) {
				tmp.push_back(nums[i]);
				for (int cnt = 0; cnt < size; cnt++) {
					ret.push_back(ret[cnt]);
					ret.back().insert(ret.back().end(), tmp.begin(), tmp.end());
				}
			}
			i = j;
		}
		return ret;
	}
};

//8ms
class Solution90_05 {
public:
	void dfs(vector<vector<int>> &res, vector<int> &ans, vector<int>& nums, int k) {
		if (k >= nums.size())
			return;
		for (int i = k; i < nums.size(); i++) {
			if (i == k || nums[i] != nums[i - 1]) {
				ans.push_back(nums[i]);
				res.push_back(ans);
				dfs(res, ans, nums, i + 1);
				ans.pop_back();
			}
		}
	}
	vector<vector<int>> subsetsWithDup(vector<int>& nums) {
		vector<vector<int>> res(1);
		vector<int> ans;
		sort(nums.begin(), nums.end());
		dfs(res, ans, nums, 0);
		return res;
	}
};

/*
//12ms
class Solution90_06 {
public:
	vector<vector<int>> subsetsWithDup(vector<int>& nums) {
		vector<vector<int> > totalset = {{}};
		sort(nums.begin(), nums.end());
		for (int i = 0; i<nums.size();) {
			int count = 0; // num of elements are the same
			while (count + i<nums.size() && nums[count + i] == nums[i])  count++;
			int previousN = totalset.size();
			vector<int> tmp;
			for (int c = 0; c < count; c++) {
				tmp.push_back(nums[i]);
				for (int j = 0; j < previousN; j++) {
					totalset.push_back(totalset[j]);
					totalset.back().insert(totalset.back().end(), tmp.begin(), tmp.end());
				}
			}
			i += count;
		}
		return totalset;
	}
};
*/

class Solution94 {
public:
	void helper(vector<int> &res, TreeNode* root) {
		if (!root) return;
		helper(res, root->left);
		res.push_back(root->val);
		helper(res, root->right);
	}
	vector<int> inorderTraversal(TreeNode* root) {
		vector<int> res;
		helper(res, root);
		return res;
	}
};


class Solution94_01 {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;
        TreeNode *it = root;
		while(1) {
			if (it->left) stk.push(it), it = it->left;
			else{
				res.push_back(it->val);
				if (it->right) it = it->right;
				else {
					while(!stk.empty() && !stk.top()->right) res.push_back(stk.top()->val), stk.pop();
					if (stk.empty()) break;
					res.push_back(stk.top()->val);
					it = stk.top()->right;
					stk.pop();
				}
			}
		}
        return res;
    }
};

class Solution94_02 {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;
        TreeNode *it = root;
		while(1) {
			if (it->left) {
				stk.push(it); 
				it = it->left;
				continue;
			}
			res.push_back(it->val);
			if (it->right) {
				it = it->right;
				continue;
			}
			else {
				while(!stk.empty() && !stk.top()->right) {
					res.push_back(stk.top()->val);
					stk.pop();
				}
				if (!stk.empty()) res.push_back(stk.top()->val), it = stk.top()->right, stk.pop();
				else break;
			}
		}
        return res;
    }
};

//Morris Traversal
//key idea is as follows:
//when current node has left, find left's rightmost node(last element of left section in inorder), set it's right as current. it is used to traverse back to current node.
//as it traverses, it would visit this current node again.
//when we check its left's rightmost, we will see it equals to the current at certain point. In this case, we know that the left section of the current is handled before.
//then set left's rightmost's right back to NULL, and move on to current right
class Solution94_03 {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        TreeNode *it = root;
        while(it) {
            if (it->left) {
                TreeNode *temp = it;
                it = it->left;
                while(it->right && it->right != temp) it = it->right;
                if (!it->right) it->right = temp, it = temp->left;
                else {
                    it->right = NULL;
                    res.push_back(temp->val);
                    it = temp->right;
                }
            }
            else {
                res.push_back(it->val);
                it = it->right;
            }
        }
        return res;
    }
};

class Solution94_033 {
public:
    vector<int> inorderTraversal(TreeNode* root) {
		vector<int> res;
		TreeNode* it = root;
		while(it) {
			if (it->left) {
				TreeNode* temp = it;
				it = it->left;
				while(it->right && it->right != temp) it = it->right;
				if (it->right) it->right = NULL, it = temp;
				else {
					it->right = temp;
					it = temp->left;
					continue;
				}
			}
			res.push_back(it->val);
			it = it->right;
		}
		return res;
    }
};

//stk stores successor
class Solution94_04 {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;
        TreeNode *it = root;
		while(1) {
		    while(it) stk.push(it), it = it->left;
		    if (stk.empty()) break;
		    it = stk.top();
		    stk.pop();
		    res.push_back(it->val);
		    it = it->right;
		}
		return res;
    }
};


class Solution91 {
public:
	int numDecodings(string s) {
		if (s.empty()) return 0;
		vector<int> dp(s.size() + 1, 0);
		dp[s.size()] = 1;
		for (int i = s.size() - 1; i >= 0; i--) {
			if (s[i] == '0') { dp[i] = 0; continue; }
			dp[i] = dp[i + 1];
			if (i < s.size() - 1 && (s[i] == '1' || (s[i]=='2' && s[i + 1] < '7'))) {
				dp[i] += dp[i + 2];
			}
		}
		return dp[0];
	}
};

class Solution91_02 {
public:
	int numDecodings(string s) {
		if (s.empty()) return 0;
		int dp0, dp1 = 1, dp2 = 0;
		for (int i = s.size() - 1; i >= 0; i--) {
			if (s[i] == '0') { dp0 = 0; }
			else {
				dp0 = dp1;
				if (i < s.size() - 1 && (s[i] == '1' || (s[i] == '2' && s[i + 1] < '7'))) {
					dp0 += dp2;
				}
			}
			dp2 = dp1; dp1 = dp0;
		}
		return dp0;
	}
};

//ListNode* head = new ListNode(1);
//head->next = new ListNode(2);
//head->next->next = NULL;
//head->next->next = new ListNode(3);
//head->next->next->next = new ListNode(4);
//head->next->next->next->next = new ListNode(5);
//head->next->next->next->next->next = NULL;
class Solution92 {
public:
	ListNode* reverseBetween(ListNode* head, int m, int n) {
		ListNode **front = &head, *it = head;
		for (int i = 0; i < m - 1; i++) front = &((*front)->next);
		it = (*front)->next;
		(*front)->next = new ListNode(0);
		ListNode** tail = &((*front)->next);
		for (int i = 0; i < n - m; i++) {
			ListNode* rest = it->next;
			it->next = *front;
			(*front) = it;
			it = rest;
		}
		*tail = it;
		return head;
	}
};

class Solution92_02 {
public:
	ListNode* reverseBetween(ListNode* head, int m, int n) {
		ListNode* dummy = new ListNode(0);
		dummy->next = head;
		ListNode *h = dummy, *it, *rest, *front;
		for (int i = 0; i < m - 1; i++) {
			h = h->next;
		}
		front = h->next;
		it = h->next->next;
		for (int i = 0; i < n - m; i++) {
			rest = it->next;
			it->next = h->next;
			h->next = it;
			it = rest;
		}
		front->next = it;
		return dummy->next;
	}
};

class Solution92_03 {
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        ListNode *dummy = new ListNode(-1);
        dummy->next = head;
        ListNode *p1 = dummy, *p2 = head, *p3 = head, *rear = head;
		int k = n - m + 1;
        while(--m) p1 = p1->next;
        p2 = p1->next;
		rear = p2;
        while(k--) {
            p3 = p2->next;
            p2->next = p1->next;
            p1->next = p2;
            p2 = p3;
        }
		rear->next = p3;
        return dummy->next;
    }
};

class Solution206 {
public:
	ListNode* reverseList(ListNode* head) {
		if (!head) return head;
		if (head->next)
		{
			ListNode *newH = reverseList(head->next);
			ListNode *p = newH;
			while (p->next) p = p->next;
			p->next = head;
			head->next = NULL;
			return newH;
		}
		return head;
	}
};

class Solution102 {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> q;
        if (root) q.push(root);
        while(!q.empty()) {
            int l = q.size();
            vector<int> temp;
            for(int i = 0; i < l; i++) {
                TreeNode* t = q.front();
                temp.push_back(t->val);
                if (t->left) q.push(t->left);
                if (t->right) q.push(t->right);
                q.pop();
            }
            res.push_back(temp);
        }
        return res;
    }
};

class Solution103 {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if (!root) return res;
        queue<TreeNode*> q;
        bool isReverse = false;
        vector<int> temp;
        q.push(root);
        q.push(NULL);
        while(!q.empty()) {
            TreeNode *t = q.front();
            q.pop();
            if (!t) {
                if (isReverse) reverse(temp.begin(), temp.end());
                res.push_back(temp);
                temp.resize(0);
                isReverse = !isReverse;
                if (!q.empty()) q.push(NULL);
            } else {
              temp.push_back(t->val);
              if (t->left) q.push(t->left);
              if (t->right) q.push(t->right);
            }
        }
        return res;
    }
};

class Solution105 {
private:
    TreeNode* helper(vector<int>& preorder, vector<int>& inorder, int preStart, int inStart, int inEnd) {
        if (inStart > inEnd) return NULL;
        auto index = find(inorder.begin() + inStart, inorder.end(), preorder[preStart]);
        TreeNode* root = new TreeNode(preorder[preStart]);
        int leftNum = distance(inorder.begin(), index) - inStart;
        root->left = helper(preorder, inorder, preStart + 1, inStart, inStart + leftNum - 1);
        root->right = helper(preorder, inorder, preStart + leftNum + 1, inStart + leftNum + 1, inEnd);
        return root;
    }
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        return helper(preorder, inorder, 0, 0, inorder.size() - 1);
    }
};

class Solution114 {
private: 
	TreeNode* helper(TreeNode* root) {
		TreeNode* p = root;
		if (root->left) {
			p = helper(root->left);
			p->right = root->right;
			root->right = root->left;
			root->left = NULL;
		}
		if (p->right) return helper(p->right);
		else return p;
	}
public:
    void flatten(TreeNode* root) {
		helper(root);
	}
};

class Solution114_02 {
private:
	TreeNode* pre;
public:
    void flatten(TreeNode* root) {
		if (!root) return;
		flatten(root->right);
		flatten(root->left);
		root->right = pre;
		root->left = NULL;
		pre = root;
	}
};

class Solution116 {
public:
    void connect(TreeLinkNode *root) {
        queue<TreeLinkNode*> q;
		q.push(root);
		q.push(NULL);
		while(!q.empty()) {
			TreeLinkNode* p = q.front();
			q.pop();
			if (!p) {
				if(!q.empty()) {
				    q.push(NULL);
				    continue;
				}
				else break;
			}
			if (p->left) q.push(p->left);
			if (p->right) q.push(p->right);
			p->next = q.front();
		}
    }
};

class Solution116_02 {
public:
    void connect(TreeLinkNode *root) {
        if (!root) return;
        root->next = NULL;
        TreeLinkNode *first = root;
        TreeLinkNode *it = root;
        while(it->left) {
            it->left->next = it->right;
            it->right->next = (it->next) ? it->next->left : NULL;
            if (it->next) it = it->next;
            else first = first->left, it = first;
        }
    }
};


class Solution117 {
public:
    void connect(TreeLinkNode *root) {
		if (!root) return;
		queue<TreeLinkNode*> q;
		q.push(root);
		q.push(NULL);
		while(!q.empty()) {
			TreeLinkNode *p = q.front();
			q.pop();
			if (!p) {
				if (q.empty()) break;
				q.push(NULL);
				continue;
			}
			if (p->left) q.push(p->left);
			if (p->right) q.push(p->right);
			p->next = q.front();
		}
    }
};

class Solution206_02 {
public:
	ListNode* reverseList(ListNode* head) {
		ListNode *newH = NULL, *tmp = NULL;
		while (head) {
			tmp = head->next;
			head->next = newH;
			newH = head;
			head = tmp;
		}
		return newH;
	}
};

//0ms

class Solution93 {
public:
	void dfs(vector<string> &res, string sln, string &s, int index, int sum) {
		if (sum >= 4 && index == s.size()) {
			res.push_back(sln);
			return;
		}
		if (s.size() - index >  (4 - sum) * 3) return;
		
		for (int i = index; i < s.size() - (4 - sum - 1); i++) {
			string tmp = s.substr(index, i - index + 1);
			if (tmp.size() > 1 && tmp[0] == '0' || stoi(tmp) > 255) return;
			tmp += ((sum == 3) ? "" : ".");
			dfs(res, sln + tmp, s, i + 1, sum + 1);
		}
	}
	vector<string> restoreIpAddresses(string s) {
		vector<string> res;
		string sln = "";
		if (s.size() < 4) return res;
		dfs(res, sln, s, 0, 0);
		return res;
	}
};


class SolutionTwoSum {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
		vector<int> result;
		unordered_map <int, int> numMap;
		for (int i = 0; i < nums.size(); i++){
			numMap[nums[i]] = i;
		}
		for (int i = 0; i < nums.size();i++){
			if ((numMap.find(target - nums[i]) != numMap.end()) && (numMap[target - nums[i]] > i)){
				result.push_back(i+1);
				result.push_back(numMap[target - nums[i]] + 1);
				return result;
			}
		}
    }
};

class Solution4Sum {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
		vector<vector<int>> res;
		vector<int> v(nums.begin(), nums.end());
		std::sort(v.begin(), v.end());

		for(int i = 0; i < v.size(); i++){
			int front = i + 1;
			int rear = v.size() - 1;
			int target = -v[i];

			while (front <  rear){
				if ((v[front] + v[rear]) < target){
					front++;
				}
				else if ((v[front] + v[rear]) > target){
					rear--;
				}
				else{
					vector<int> ans;
					ans.push_back(v[i]);
					ans.push_back(v[front]);
					ans.push_back(v[rear]);
					res.push_back(ans);
					
					front++;
					rear--;
					while((front<rear) && (v[front]==v[front-1])){
						front++;
					}
					while((front<rear) && (v[rear]==v[rear+1])){
						rear--;
					}
				}
			}
		}

		return res;
    }
};

/*
class Solution18_02 {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> res;
		unordered_map<int, vector<pair<int, int>>> cache;
		if (nums.size() < 4) return res;
		sort(nums.begin(), nums.end());
		auto last = nums.end();
		for(auto i = 0; i < nums.size(); i++){
			for(auto j = i + 1; j < nums.size(); j++){
			    cache[nums[i] + nums[j]].push_back(pair<int, int>(i, j));
			}
		}
		for(auto i = 0; i<nums.size(); i++){
			for(auto j = i+1; j<nums.size(); j++){
				int goal = target - nums[i] -nums[j];
				if (cache.find(goal)!=cache.end()){
				    const auto& vec = cache[goal];
					for(int k = 0; k < vec.size(); k++){
						if (i > vec[k].second){
							res.push_back( { nums[vec[k].first],nums[vec[k].second], nums[i], nums[j] });
						}
					}
				}
			}
		}
		
		sort(res.begin(), res.end());
		res.erase(unique(res.begin(), res.end()), res.end());
		return res;
}
        
};
*/
/*
class Solution18_03 {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> res;
        unordered_map<int, vector<pair<int, int>>> mp;
        sort(nums.begin(), nums.end());
        for(int i = 0; i < (int)nums.size() - 1; i++) {
            for(int j = i + 1; j < nums.size(); j++) {
                mp[nums[i] + nums[j]].push_back(pair<int, int>(i, j));
            }
        }
        
        for(int i = 0; i < (int)nums.size() - 1; i++) {
            for(int j = i + 1; j < nums.size(); j++) {
                int t = target - nums[i] - nums[j];
                if (mp.find(t) != mp.end()) {
                    for(int k = 0; k < mp[t].size(); k++){
                        if (mp[t][k].first > j) {
                            res.push_back({nums[i], nums[j], nums[mp[t][k].first], nums[mp[t][k].second]});
                        }
                    }
                }
            }
        }
        sort(res.begin(), res.end());
        res.erase(unique(res.begin(), res.end()), res.end());
        return res;
    }
        
};
*/


class SolutionAddTwo{
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
		ListNode *root = new ListNode(0);
		ListNode *p = root;
		int c = 0;
		while(l1 || l2 || c){
			if(l1) c += l1->val, l1 = l1->next;
			if(l2) c += l2->val, l2 = l2->next;
			ListNode *digit = new ListNode(c%10);
			p->next = digit;
			p = p->next;
			c = c/10;
		}
		return root->next;
    }
};

class SolutionLengthOfLongestSubstring {
public:
    int lengthOfLongestSubstring(string s) {
		vector<int> position(256, -1);
		int longest = 0;
		int front = 0;
		for(int rear = 0; rear < s.size(); rear++){
			if (position[s[rear]] >= front){
				longest = max(longest, rear - front);
				front = position[s[rear]]+1;
			}
		    position[s[rear]] = rear;
		}
		longest = max(longest, int(s.size() - front));
        return longest;
    }
};

class Solution13 {
private:
   int map(const char c) {
       switch (c){
           case 'I': return 1;
           case 'V': return 5;
           case 'X': return 10;
           case 'L': return 50;
           case 'C': return 100;
           case 'D': return 500;
           case 'M': return 1000;
           default: return 0;
       }
   }
public:
    int romanToInt(string s) {
        if (s.size() == 0) return 0;
        if (s.size() == 1) return map(s[0]);
        int res = map(s[0]);
        for(int i = 1; i < s.size(); i++) {
            if (map(s[i - 1]) >= map(s[i])) res += map(s[i]);
            else {
                res = res - map(s[i - 1]) * 2 + map(s[i]);
            }
        }
        return res;
    }
};

class Solution15 {
public:
    string longestCommonPrefix(vector<string>& strs) {
		if (strs.size() == 0) return "";
        if (strs.size() == 1) return strs[0];
        string res = "";
        int k = 0;
        while(1){
            for(int i = 1; i<=strs.size()-1;i++){
                if ((k>=strs[i].size()) || (strs[i][k] != strs[i-1][k]))
                    return res;
            }
            res.push_back(strs[0][k++]);
        }
        return res;
    }
};

class Solution16 {
public:
    int threeSumClosest(vector<int>& nums, int target) {
		sort(nums.begin(), nums.end());
		int sum = nums[0] + nums[1] + nums[2];
		for(int i = 0; i< nums.size() - 2; i++){
			int j = i + 1;
			int k = nums.size() - 1;
			while(j<k){
				sum = (abs(nums[i] + nums[j] + nums[k] - target)<abs(target - sum)) ? nums[i] + nums[j] + nums[k] : sum;
				(sum > target) ? k-- : j++;
				if (sum == target)
					return target;
			}
		}
		return sum;
    }
};
class Solution17_02 {
public:
	vector<vector<int>> fourSum(vector<int>& nums, int target) {
		vector<vector<int>> res;
		if (nums.size()<4) return res;
		sort(nums.begin(), nums.end());
		auto last = nums.end();
		for(auto i = nums.begin(); i < prev(last, 3); i++){
			for(auto j = next(i); j < prev(last, 2); j++){
				auto k = next(j);
				auto l = prev(last);
				while(k<l){
					int sum = *i+*j+*k+*l;
					if (sum>target){
						l--;
					}else if (sum<target){
						k++;
					}else{
						vector<int> ans;
						ans.push_back(*i);
						ans.push_back(*j);
						ans.push_back(*k);
						ans.push_back(*l);
						res.push_back(ans);
						while((k<l)&&(*k==*(k+1)))
							k++;
						while((k<l)&&(*l==*(l-1)))
							l--;
						k++; l--;
					}
				}
			}
		}
		sort(res.begin(), res.end());
		res.erase(unique(res.begin(), res.end()), res.end());

		return res;
	}
};


class Solution17_01 {
public:
	vector<vector<int>> fourSum(vector<int>& nums, int target) {
		vector<vector<int>> res;
		unordered_map<int, vector<pair<int, int>>> cache;
		if (nums.size() < 4) return res;
		sort(nums.begin(), nums.end());
		auto last = nums.end();
		for(auto i = nums.begin(); i < prev(last); i++){
			for(auto j = next(i); j < last; j++){
				int sum = *i + *j;
				if (cache.find(sum)==cache.end()){
					vector<pair<int, int>> entry;
					entry.push_back(pair<int, int>(*i, *j));
					cache[sum] = entry;
				}
				else{
					cache[sum].push_back(pair<int, int>(*i, *j));
				}
			}
		}
		for(auto i = 0; i<nums.size() - 3; i++){
			for(auto j = i+1; j<nums.size() -2; j++){
				int goal = target - nums[i] -nums[j];
				if (cache.find(goal)!=cache.end()){
					for(int k = 0; k < cache[goal].size(); k++){
						if (cache[goal][k].second > j){
							vector<int> ans;
							ans.push_back(nums[i]);
							ans.push_back(nums[i]);
							ans.push_back(cache[goal][k].first);
							ans.push_back(cache[goal][k].second);
						}
					}
				}
			}
		}
		
		sort(res.begin(), res.end());
		res.erase(unique(res.begin(), res.end()), res.end());
		return res;
	}
};

class Solution21 {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* node1 = l1;
        ListNode* node2 = l2;
        ListNode* head = new ListNode(0);
        ListNode* rear = head;
        while(node1 || node2){
            if (!node1){
                rear->next = new ListNode(node2->val);
				node2 = node2->next;
				rear = rear->next;
                continue;
            }
            if (!node2) {
                rear->next = new ListNode(node1->val);
				node1 = node1->next;
				rear = rear->next;
                continue;
            }
            if (node1->val <= node2->val){
                rear->next = new ListNode(node1->val);
                rear = rear->next;
                node1 = node1->next;
            }
            else {
                rear->next = new ListNode(node2->val);
                rear = rear->next;
                node2 = node2->next;
            }
        }
        return head->next;
    }
};

class Solution21_1 {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* head = NULL;
        ListNode** it = &head;
        while(l1 && l2){
            if (l1->val <= l2->val){
                *it = l1;
                l1 = l1->next;
            }
            else {
                *it = l2;
                l2 = l2->next;
            }
            it = &((*it)->next);
        }
        *it = l1? l1:l2;
        return head;
    }
};

class Solution21_2 {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* head=NULL;
        ListNode** it = &head;
        while(l1 && l2){
            if (l1->val <= l2->val){
                *it = l1;
                l1 = l1->next;
            }
            else {
                *it = l2;
                l2 = l2->next;
            }
			it = &((*it)->next);
        }
        *it = l1? l1:l2;
        return head;
    }
};

class Solution22 {
public:
	void dfs(vector<string> &res, string ans, int lLeft, int rLeft){
		if (lLeft==0 && rLeft == 0){
			res.push_back(ans);
			return;
		}
		if(lLeft>0){
			dfs(res, ans+"(", lLeft - 1, rLeft);
		}
		if(lLeft < rLeft){
			dfs(res, ans+")", lLeft, rLeft - 1);
		}
	}
    vector<string> generateParenthesis(int n) {
        vector<string> res;
		dfs(res, "", n, n);
		return res;
    }
};

class Solution22_1 {
public:
    vector<string> generateParenthesis(int n) {
		vector<vector<string>> f;
		f.push_back(vector<string>(1,"")); //f[0]
		f.push_back(vector<string>(1,"()")); //f[0]
		for(int i = 2; i<= n; i++){
			vector<string> ans;
			for(int j = 1; j <= i-1; j++){
				
				for(int a = 0; a< f[j].size(); a++){
					for(int b = 0; b< f[i-j].size(); b++){
						ans.push_back(f[j][a]+f[i-j][b]);
					}
				}
			}
			f.push_back(ans);
		}
		return f[n];
    }
};

class Solution23_02 {

public:

    // custom comparator used to compare between two listNode pointers. 
    // note : all pointers to be compared is supposed to be valid pointers.
    struct comparator
    {
        bool operator() ( ListNode* i, ListNode* j)
         {
            return i->val > j->val;
         }
    };

    ListNode *mergeKLists(vector<ListNode *> &lists) 
    {

       // shortcut for edge cases. 
       if (lists.size() == 0) return NULL;
       if (lists.size() == 1) return lists[0]; 

       // initialize the maxHeap. 
       priority_queue<ListNode*, std::vector<ListNode*>, comparator> maxHeap;

       // push the head of each of the items in list. 
       for (int i = 0; i< lists.size(); i++)
       {
           if (lists[i]!= NULL) maxHeap.push(lists[i]);
       }

       // shortcut if we failed to find even one valid list. 
       if (maxHeap.size() == 0) return NULL;

       // build the empty node as the return pointer.
       ListNode returnVal = ListNode(-1), *tmp = &returnVal; 

       // loop until the heap is empty. 
       while (maxHeap.size() >0)
       {
           tmp->next = maxHeap.top();
           maxHeap.pop();
           tmp = tmp->next;
           if (tmp->next != NULL && maxHeap.size()!=0)
           {
               maxHeap.push(tmp->next);
           }
       }

       return returnVal.next;
    }
};

class Solution24 {
public:
    ListNode* swapPairs(ListNode* head) {
		ListNode** it = &head;
		ListNode* temp;
		while(*it && (*it)->next){
			temp = (*it)->next;
			(*it)->next = (*it)->next->next;
			temp->next = *it;
			*it = temp;
			it = &((*it)->next->next);
		}
		return head;
    }
};

class Solution25 {
public:
	ListNode* reverseList(ListNode* head){
		ListNode** it = &head;
		if((*it)->next){
			ListNode* tempHead = (*it)->next;
			ListNode* temp = reverseList((*it)->next);
			tempHead->next = *it;
			(*it)->next = NULL;
			*it = temp;
		}
		return head;
	}
    ListNode* reverseKGroup(ListNode* head, int k) {
		ListNode** secHead = &head;
		ListNode* secTail = NULL;
		ListNode** it = &head;
		ListNode* left;
		int m = k;
		while(*it){
			while(*it && m>0){
				m--;
				it = &((*it)->next);
			}
			if(m==0){
				left = *it;
				*it = NULL;
				secTail = *secHead;
				*secHead = reverseList(*secHead);
				secTail->next = left;
				secHead = &(secTail->next);
				it = secHead;
				m = k;
			}
		}
		return head;
    }
};

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution25_02 {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if (!head || k <= 1) return head;
        ListNode **it = &head, *pRear = head, *p1 = head, *p2;
        int count = k;
        while(p1) {
			if (count-- == 0) {
				pRear->next = p1;
				it = &(pRear->next);
				pRear = p1; 
				count = k; 
				continue;
			}
            p2 = p1->next;
            p1->next = *it;
            *it = p1;
            p1 = p2;
        }
        pRear->next = NULL;
        if (count > 0) *it = reverseKGroup(*it, k - count);
        return head;
    }
};

class Solution26 {
public:
    int removeDuplicates(vector<int>& nums) {
		if (nums.empty()) return 0;
        sort(nums.begin(), nums.end());
        nums.erase(unique(nums.begin(), nums.end()), nums.end());
        return nums.size();
    }
};

class Solution26_01 {
public:
    int removeDuplicates(vector<int>& nums) {
        int count = 0;
        int n = nums.size();
        for(int i = 1; i < n; i++){
            if(nums[i] == nums[i-1]) count++;
            else nums[i-count] = nums[i];
        }
        return n-count;     
    }
};

class Solution26_02 {
public:
    int removeDuplicates(vector<int>& nums) {
        return distance(nums.begin(), unique(nums.begin(), nums.end()));
    }
};

class Solution28 {
public:
    int removeElement(vector<int>& nums, int val) {
        int l = nums.size();
		int count = 0;
		for(int i = 0; i < l; i++){
			if (nums[i] == val) count++;
			else nums[i-count] = nums[i];
		}
		return l-count;
    }
};

class Solution29 {
public:
    int strStr(string haystack, string needle) {
		int res = -1;
		int l = needle.size();
		for(int i = 0; i<= ((int)haystack.size() - (int)needle.size());i ++){
			if (haystack.substr(i,l) == needle){
				return i;
			}
		}
        return res;
    }
};

class Solution29_01 {
public:
	typedef long long ll;
    int divide(int dividend, int divisor) {
		if (divisor ==0) return INT_MAX;
		if (dividend ==0) return 0;
		if ((dividend == INT_MIN) && (divisor == -1)) return INT_MAX;
		ll res=0;
		int sign = ((dividend>0)&&(divisor>0)) || ((dividend<0)&&(divisor<0)) ? 1 : -1;
		ll dd = abs((ll)dividend);
		ll dr = abs((ll)divisor);
		while(dd>=dr){
			ll a = dr;
			int m = 1;
			while(a<<1<dd){
				a=a<<1; m=m<<1;
			}
			res+=m;
			dd-=a;
		}
		return res*sign;
    }
};
//all items meet at lease once
//at most twice
//like grab all the items and place them into the correct place
//each number for the first time meet will be place into the correct place
//so all the numbers covered will be placed correctly
//the slot is missing is the what is missing
class Solution41 {
public:
    int firstMissingPositive(vector<int>& nums) {
		for(int i = 0; i < nums.size(); i++){
			while ((nums[i]>0) && (nums[i] <= nums.size()) && (nums[i] != nums[nums[i]-1]))
				swap(nums[i], nums[nums[i]-1]);
		}
		for(int i = 0; i< nums.size(); i++){
			if (nums[i] != i+1)
				return i+1;
		}
        return nums.size()+1;
    }
};

class Solution42 {
public:
    int trap(vector<int>& height) {
        if (height.empty()) return 0;
		int res = 0;
		int l = 0;
		int r = height.size() -1;
		while(l<r){
			int lh = height[l];
			int rh = height[r];
			if (lh<=rh){
				while((l<=r)&&(height[l]<=lh)){
					res+=lh-height[l];
					l++;
				}
			}
			else{
				while((l<=r)&&(height[r]<=rh)){
					res+=rh-height[r];
					r--;
				}
			}
		}
		return res;
    }
};

class Solution42_01 {
public:
    int trap(vector<int>& height) {
		//scan A both from left to right and right to left, record the largest seen during the scan; then for each position the water level should be the min of the 2 large value.
		int res = 0;
		int n = height.size();
		vector<int> lhs(n,0), rhs(n, 0);
		if(!n) return 0;
		lhs[0] = height[0]; rhs[n-1] = height[n-1];
		for(int i = 1; i < n; i++){
			lhs[i] = max(lhs[i-1], height[i]);
		}
		for(int i = n-2; i >=0; i--){
			rhs[i] = max(rhs[i+1], height[i]);
		}
		for(int i = 0; i < n; i++){
			res += min(lhs[i], rhs[i]) - height[i];
		}
		return res;
    }
};



class Solution43 {
public:
    string multiply(string num1, string num2) {
		string sum(num1.size() + num2.size(), '0');
		for(int i = num2.size() - 1; i>=0; i--){
			int carry = 0;
			for(int j = num1.size() - 1; j >=0; j--){
				int m = (num1[j] - '0') * (num2[i] - '0') + (sum[i+j+1] - '0') + carry;
				sum[i+j+1] = '0' + m % 10;
				carry = m / 10;
			}
			sum[i] = '0' + carry;
		}
		auto it = sum.find_first_not_of('0');
		return (it==string::npos) ? "0" : sum.substr(it);
    }
};

class Solution45_02 {
public:
    int jump(vector<int>& nums) {
		if (nums.size() == 1) return 0;
		int res = 1;
		int l = 0, r = nums[0];
		int maxL = r;
		while(maxL < nums.size() - 1){
			int newL = -1;
			for(int i = l; i <=r; i++){
				if (i + nums[i] > maxL){
					maxL = i + nums[i];
					newL = i;
					if (maxL >= (nums.size()-1)){return res + 1;}  //will reach in next step
				}
			}
			l = newL;
			r = maxL;
			res++; //ready for next step
		}
		return res;
    }
};

class Solution46 {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> res;
		if (nums.empty()) return res;
		sort(nums.begin(), nums.end());
		int n = 1;
		for(int i = 2; i <= nums.size(); i++){
			n*=i;
		}
		while(n>0){
			res.push_back(nums);
			next_permutation(nums.begin(), nums.end());
			n--;
		}
		return res;
    }
};

class Solution46_01 {
public:
    void permute_recursive(vector<int> nums, int k, vector<vector<int>>& res){
		if (k==nums.size()-1){
			res.push_back(nums);
			return;
		}
		for(int i = k; i < nums.size(); i++){
			swap(nums[k], nums[i]);
			permute_recursive(nums, k + 1, res);
		}
	}
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> res;
		sort(nums.begin(), nums.end());
		permute_recursive(nums, 0, res);
		return res;
    }
};

class Solution47 {
public:
	void permute_recursive(vector<int> nums, int k, vector<vector<int>>& res){
		if (k==nums.size()-1){
			res.push_back(nums);
			return;
		}
		
	    permute_recursive(nums, k + 1, res);
		for(int i = k + 1; i < nums.size(); i++){
			if (nums[i] == nums[i - 1]){continue;}
			swap(nums[k], nums[i]);
			permute_recursive(nums, k + 1, res);
		}
	}
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        vector<vector<int>> res;
		sort(nums.begin(), nums.end());
		permute_recursive(nums, 0, res);
		return res;
    }
};
//Solution48 slu48;
//vector<vector<int>> matrix;
//vector<int> row1; row1.push_back(1); row1.push_back(2); row1.push_back(3); row1.push_back(4);
//vector<int> row2; row2.push_back(5); row2.push_back(6); row2.push_back(7); row2.push_back(8);
//vector<int> row3; row3.push_back(9); row3.push_back(10); row3.push_back(11); row3.push_back(12);
//vector<int> row4; row4.push_back(13); row4.push_back(14); row4.push_back(15); row4.push_back(16);
//matrix.push_back(row1); matrix.push_back(row2); matrix.push_back(row3); matrix.push_back(row4);
//slu48.rotate(matrix);

class Solution48 {
public:
    void rotate(vector<vector<int>>& matrix) {
		int n = matrix.size();
		for(int i = 0; i <= (n-1)/2; i++){
			for(int j = i; j < n - i -1; j++){
				int m = matrix[i][j];
				matrix[i][j] = matrix[n-1-j][i];
				matrix[n-1-j][i] = matrix[n-1-i][n-1-j];
				matrix[n-1-i][n-1-j] = matrix[j][n-1-i];
				matrix[j][n-1-i] = m;
			}
		}
        
    }
};

class Solution50_02 {
public:
	double myPowPositive(double x, int n){
		if (n == 0) return 1;
		if (n == 1) return x;
		double t= myPow(x, n/2);
		if (n%2==1) return t * t * t;
		else return t * t;
	}
    double myPow(double x, int n) {
		if (n<0)
			return myPowPositive(1/x, -n);
		else return myPowPositive(x, n);
    }
};

class Solution51 {
public:
	void dfs(vector<vector<string>>& res, vector<string>& sln, vector<int>& col, vector<int>& diag0, vector<int>& diag1, int k, int n){
		if (k==n){
			res.push_back(sln);
			return;
		}
		for(int i = 0; i < n; i++){
			if ((col[i] == 0) && (diag0[i + k] == 0) && diag1[n - i + k] == 0){
				sln[k][i] = 'Q';
				col[i] = 1; diag0[i + k] = 1; diag1[n - i + k] = 1;
				dfs(res, sln, col, diag0, diag1, k + 1, n);
				col[i] = 0; diag0[i + k] = 0; diag1[n - i + k] = 0;
				sln[k][i] = '.';
			}
		}
	}
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<string>> res;
		string row(n, '.');
		vector<string> sln(n, row);
		vector<int> col(n, 0);
		vector<int> diag0(2*n-1, 0);
		vector<int> diag1(2*n-1, 0);
		dfs(res, sln, col, diag0, diag1, 0, n);
		return res;
    }
};

class Solution53 {
public:
    int maxSubArray(vector<int>& nums) {
        int res = nums[0];
		int act = nums[0];
		for(int i = 1; i < nums.size(); i++){
		    if (act<0) act = nums[i];
		    else act +=nums[i];
			if(act > res){
				res = act;
			}
		}
		return res;
    }
};

class Solution55 {
public:
    bool canJump(vector<int>& nums) {
		int maxL = 0;
		for(int i = 0; i<=maxL && i <nums.size(); i++){
			maxL = max(maxL, i + nums[i]);
		}
		return maxL >= nums.size() - 1;
    }
};

//vector<vector<int>> matrix(1, vector<int>(3, 1));
//matrix[0][0] = 1; matrix[0][1] = 3; matrix[0][2] = 5;
//bool res = sln74.searchMatrix(matrix, 1);
class Solution74 {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if (matrix.empty()) return false;
		int m = matrix.size(), n = matrix[0].size();
		int rowL = 0, colL = 0, rowR = m - 1, colR = n - 1;
		while (rowL < rowR || (rowL == rowR && colL <= colR)) {
			int diff = (rowR - rowL) * n + colR - colL;
			int midRow = (rowL * n + colL + diff / 2) / n, midCol = (rowL * n + colL + diff / 2) % n;
			int tmp = matrix[midRow][midCol];
			if (tmp == target) return true;
			if (tmp > target) {
				midCol--;
				if (midCol < 0) { midRow--; midCol = n - 1;}
				rowR = midRow; colR = midCol;
			}
			else { 
				midCol++;
				if (midCol >= n) { midRow++; midCol = 0; }
				rowL = midRow; colL = midCol; 
			}
		}
		return false;
    }
};

class Solution74_02 {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if (matrix.empty()) return false;
		int m = matrix.size(), n = matrix[0].size();
		int l = 0, r = m * n - 1;
		while(l <= r){
			int mid = (l + r) / 2, tmp = matrix[mid/n][mid%n];
			if (tmp == target) return true;
			if (target < tmp) r = mid - 1;
			else l = mid + 1;
		}
		return false;
    }
};
//classic: Dutch national flag problem
class Solution75 {
public:
    void sortColors(vector<int>& nums) {
        int w = -1, r = -1, b = -1;
		for(int i = 0; i < nums.size(); i++){
			if (nums[i] == 0){
				nums[++b] = 2; nums[++r] = 1; nums[++w] = 0;
			}
			else if (nums[i] == 1){
				nums[++b] = 2; nums[++r] = 1;
			}
			else {
				nums[++b] = 2;
			}
		}
    }
};

class Solution75_02 {
public:
    void sortColors(vector<int>& nums) {
		int w = 0, b = nums.size() - 1;
		for(int i = 0; i <= b; i++){
			if (nums[i] == 0)
				swap(nums[w++], nums[i]);  //nums[w] is first not 0, and should be 1. this is to swap the first "1" with the current "0"
			else if (nums[i] == 2 )
				swap(nums[b--], nums[i--]);
		}
    }
};

class Solution77 {
public:
	void dfs(vector<vector<int>> &res, vector<int>& sln, int n, int k, int p, int d){
		if (p == k){
			res.push_back(sln);
			return;
		}
		for(int i = d; i <= n - k + p + 1; i++){
			sln[p] = i;
			dfs(res, sln, n, k, p + 1, i + 1);
		}
	}
    vector<vector<int>> combine(int n, int k) {
		vector<vector<int>> res;
		vector<int> sln(k, 0);
		dfs(res, sln, n, k, 0, 1);
		return res;
    }
};

//ListNode* head = new ListNode(1);
//head->next = new ListNode(1);
//head->next->next = new ListNode(2);
//head->next->next->next = new ListNode(2);
//head->next->next->next->next = new ListNode(3);
//ListNode* res = sln82.deleteDuplicates(head);
class Solution82 {
public:
    ListNode* deleteDuplicates(ListNode* head) {
		if (!head) return NULL;
        ListNode **it = &head, **front = NULL;
		int pre = head->val - 1;
		bool dup = false;
		while (*it) {
			if ((*it)->val == pre){
				dup = true;
			}
			else{
				if (front && dup)
					*front = *it;
				else front = it;
				pre = (*it)->val;
				dup = false;
			}
			it = &((*it)->next);
		}
		if (dup) 
			*front = NULL;
		return head;
    }
};

class Solution82_02 {
public:
    ListNode* deleteDuplicates(ListNode* head) {
		if (!head || !head->next) return head;
        ListNode **it = &head;
		while(*it){
			if ((*it)->next && (*it)->val == (*it)->next->val){
				ListNode* p = (*it)->next;
				while(p->next && p->next->val == p->val)
					p = p->next;
				*it = p->next;
			}
			else{
				it = &((*it)->next);
			}
		}
		return head;
    }
};

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */

//like this one
class Solution82_04 {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode **it = &head;
        if (!head) return head;
        bool dup = false;
        while(*it) {
            while((*it)->next && (*it)->next->val == (*it)->val) {
                dup = true;
                *it = (*it)->next;
            }
            if (dup) *it = (*it)->next;
            else it = &((*it)->next);
			dup = false;
        }
        return head;
    }
};

class Solution83 {
public:
	int largestRectangleArea(vector<int>& height) {
		stack<int> s;
		height.push_back(0);
		int result = 0;
		for (int i = 0; i < height.size(); ) {
			if (s.empty() || height[i] > height[s.top()])
				s.push(i++);
			else {
				int tmp = s.top();
				s.pop();
				result = max(result,
					height[tmp] * (s.empty() ? i : i - s.top() - 1));
			}
		}
		return result;
	}
};

class Solution83_02 {
public:
	int largestRectangleArea(vector<int>& height) {
		int res = 0;
		stack<int> stk;
		height.push_back(0);
		for(int i = 0; i < height.size(); i++){
			if (stk.empty() || height[i] >= height[stk.top()])
				stk.push(i);
			else{
				int tmp = stk.top();
				stk.pop();
				int newMax = (stk.empty()) ? height[tmp] * i : height[tmp] * (i - stk.top() - 1);
				res = max(res, newMax);
				i--;
			}
		}
		return res;
	}
};

class Solution95 {
public:
	vector<TreeNode*> generate(int l, int r){
		if (l > r) return vector<TreeNode*>(1, NULL);
		vector<TreeNode*> res;
		for(int i = l; i <= r; i++){
			vector<TreeNode*> lRes = generate(l, i - 1);
			vector<TreeNode*> rRes = generate(i + 1, r);
			for(int ll = 0; ll < lRes.size(); ll++){
				for(int rr = 0; rr < rRes.size(); rr++){
					TreeNode* head = new TreeNode(i);
					head->left = lRes[ll]; head->right = rRes[rr];
					res.push_back(head);
				}
			}
		}
		return res;
	}
    vector<TreeNode*> generateTrees(int n) {
        vector<TreeNode*> res;
		res = generate(1, n);
		return res;
    }
};

class Solution96 {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1, 0);
		dp[0] = 1; dp[1] = 1;
		for(int i = 2; i <= n; i++){
			for(int j = 1; j <= i; j++){
				dp[i] += dp[j - 1] *  dp[i - j];
			}
		}
		return dp[n];
    }
};

class Solution98 {
public:
	bool isValid(TreeNode* root, TreeNode* minNode, TreeNode* maxNode){
		if (root == NULL) return true;
		if ((minNode && root->val <= minNode->val) || (maxNode && root->val >= maxNode->val))
			return false;
		if ((root->left && !isValid(root->left, minNode, root)) || (root->right && !isValid(root->right, root, maxNode)))
			return false;
		return true;
	}
	bool isValid2(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) {
		if (!root) return true;
		if (minNode && minNode->val >= root->val) return false;
		if (maxNode && maxNode->val <= root->val) return false;
		return isValid(root->left, minNode, root) && isValid(root->right, root, maxNode);
	}
    bool isValidBST(TreeNode* root) {
        return isValid(root, NULL, NULL);
    }
};

class Solution98_02 {
public:
	//https://leetcode.com/discuss/14886/order-traversal-please-rely-buggy-int_max-int_min-solutions
	bool isValid(TreeNode* root, TreeNode* &prev){
		if (!root) return true;
		if (root->left && !isValid(root->left, prev)) return false;
		if (prev && prev->val >= root->val) return false;
		prev = root;
		return isValid(root->right, prev);
	}
    bool isValidBST(TreeNode* root) {
		TreeNode* prev = NULL;
        return isValid(root, prev);
    }
};

class Solution98_03 {
private:
	bool isValid(TreeNode* root, TreeNode* &prev){
		if (!root) return true;
		if (!isValid(root->left, prev)) return false;
		if (prev && root->val <= prev->val) return false;
		prev = root;
		if (!isValid(root->right, prev)) return false;
		return true;
	}
public:
    bool isValidBST(TreeNode* root) {
		TreeNode *prev = NULL;
		return isValid(root, prev);
    }
};

class Solution99 {
public:
    bool isInterleave(string s1, string s2, string s3) {
		int l1 = s1.size(), l2 = s2.size(), l3 = s3.size();
		if (l1 + l2 != l3) return false;
        vector<vector<bool>> dp(l1 + 1, vector<bool>(l2 + 1, false));
		dp[0][0] = true;
		for(int i = 1; i <= l1; i++){
			dp[i][0] = s1.substr(0, i) == s3.substr(0, i);
			if (!dp[i][0]) break;
		}
		for(int j = 1; j <= l2; j++){
			dp[0][j] = s2.substr(0, j) == s3.substr(0, j);
			if (!dp[0][j]) break;
		}
		for(int i = 1; i <= l1; i++){
			for(int j = 1; j <= l2; j++){
				dp[i][j] = (s1[i - 1] == s3[i+j-1] && dp[i-1][j]) || (s2[j-1] == s3[i+j-1] && dp[i][j-1]);
			}
		}
		return dp[l1][l2];
    }
};
class Solution99New {
private:
	void traverse(TreeNode* root, TreeNode* &prev, TreeNode* &first, TreeNode* &second){
		if (!root) return;
		traverse(root->left, prev, first, second);
		if (prev && prev->val > root->val) {
			if (!first) first = prev;
			second = root;
		}
		prev = root;
		traverse(root->right, prev, first, second);
	}
public:
    void recoverTree(TreeNode* root) {
        TreeNode *firstNode = NULL, *secondNode = NULL, *prevNode = NULL;
		traverse(root, prevNode, firstNode, secondNode);
		swap(firstNode->val, secondNode->val);
    }
};


class Solution108 {
private:
	TreeNode* helper(vector<int>& nums, int start, int end) {
		if (start > end) return NULL;
		int mid = start + (end-start)/2;
		TreeNode* root = new TreeNode(nums[mid]);
		root->left = helper(nums, start, mid - 1);
		root->right = helper(nums, mid + 1, end);
		return root;
	}
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
		return helper(nums, 0, (int)nums.size() - 1);
    }
};

//(nlog(n))
class Solution109 {
private:
	TreeNode* helper(ListNode* head, ListNode* tail) {
		if (head == tail) return NULL;
		ListNode *slow = head, *fast = head;
		while(fast->next != tail && fast->next->next != tail) {
			slow = slow->next;
			fast = fast->next->next;
		}
		TreeNode *root = new TreeNode(slow->val);
		root->left = helper(head, slow);
		root->right = helper(slow->next, tail);
		return root;
	}
public:
    TreeNode* sortedListToBST(ListNode* head) {
		return helper(head, NULL);
    }
};

//log(n)
class Solution109_fast {
private:
	TreeNode* helper(ListNode* &cur, int start, int end) {
		if(start > end) return NULL;
		int mid = start + (end - start) / 2;
		TreeNode* left = helper(cur, start, mid - 1);
		TreeNode* root = new TreeNode(cur->val);
		root->left = left;
		cur = cur->next;
		root->right = helper(cur, mid + 1, end);
		return root;
	}
public:
    TreeNode* sortedListToBST(ListNode* head) {
		int len = 0;
		ListNode* p = head;
		while(p) len++, p=p->next;
		ListNode* cur = head;
		return helper(cur, 1, len);
    }
};


class Solution125 {
public:
    bool isAlphanumeric(char c) {
        return ('a' <= c && c <='z') || ('A' <= c && c <='Z') || ('0' <= c && c <='9');
    }
    bool isPalindrome(string s) {
        int l = 0, r = s.size() - 1;
        while(l < r) {
            while(l < r && !isAlphanumeric(s.at(l))) l++;
			while(l < r && !isAlphanumeric(s.at(r))) r--;
            if (tolower(s.at(l)) != tolower(s.at(r))) return false;
			l++; r--;
        }
        return true;
    }
};

class Solution134 {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int n = gas.size();
        int start = 0, end = 0;
        int sum = 0;
        int k = 0;
        while(k++ < n) {
            if (sum + gas[end] - cost[end] >= 0) {
                sum += gas[end] - cost[end];
                end = (end + 1) % n;
            }
            else {
                start = (n + start - 1) % n;
                sum += gas[start] - cost[start];
            }
        }
        return (sum >= 0) ? start : -1;
    }
};

class TrieNode140 {
public:
	static const int charSize = 26;
	TrieNode140* next[charSize];
	string word;
	TrieNode140() {
		word = "";
		memset(next, 0, sizeof(next));
	}
	~TrieNode140() {
		for (int i = 0; i < charSize; i++) delete next[i];
	}
};

class Solution140 {
private:
	TrieNode140* root;
	void InitTree(unordered_set<string>& wordDict) {
		root = new TrieNode140();
		for (auto word : wordDict) {
			Insert(word);
		}
	}
	void Insert(string word) {
		TrieNode140* p = root;
		for (int i = 0; i < word.size(); i++) {
			char c = word[i] - 'a';
			if (!p->next[c]) p->next[c] = new TrieNode140();
			p = p->next[c];
		}
		p->word = word;
	}

	void dfs(string &s, int i, TrieNode140* node, string temp, vector<string> &res) {
		if (i == s.size()) {
			if (node == root) res.push_back(temp.substr(1));
			return;
		}
		node = node->next[s[i] - 'a'];
		while (node) {
			if (node->word.size() > 0) {
				temp += " " + node->word;
				dfs(s, i + 1, root, temp, res);
				temp.erase(temp.end() - (node->word).size() - 1, temp.end());
			}
			node = (i++ < s.size() - 1) ? node->next[s[i] - 'a'] : NULL;
		}
	}

public:
	vector<string> wordBreak(string s, unordered_set<string>& wordDict) {
		vector<string> res;
		if (s.empty()) return res;
		InitTree(wordDict);
		string temp = "";
		dfs(s, 0, root, temp, res);
		return res;
	}
};


class Solution144 {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        TreeNode *it = root;
        vector<int> res;
        while(it) {
            if (it->left) {
                TreeNode *temp = it;
                it = it->left;
                while(it->right && it->right != temp) it = it->right;
                if (!it->right) it->right = temp, res.push_back(temp->val), it = temp->left;
                else it->right = NULL, it = temp->right;
            }
            else {
                res.push_back(it->val);
                it = it->right;
            }
        }
        return res;
    }
};

//stk stores successor 
class Solution144_02 {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        TreeNode *it = root;
        vector<int> res;
        stack<TreeNode*> stk;
        while(1) {
            while(it) res.push_back(it->val), stk.push(it), it = it->left;
            if (stk.empty()) break;
            it = stk.top()->right;
            stk.pop();
        }
        return res;
    }
};


class Solution145 {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;
        if(!root) return res;
        TreeNode* it = root;
        TreeNode* prev = NULL;
        while(1) {
            if (it->left && it->left != prev && !(it->right && it->right == prev)) {
                stk.push(it);
                it = it->left;
            }
            else if (it->right && it->right != prev) {
                stk.push(it);
                it = it->right;
            }
			else {
                res.push_back(it->val);
				if (stk.empty()) break;
				prev = it;
                it = stk.top();
                stk.pop();
			}
        }
        return res;
    }
};

class Solution145_02 {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;
        if(!root) return res;
        TreeNode* it = root;
        TreeNode* prev = NULL;
        while(1) {
            if (it->left && it->left != prev && (!it->right || it->right != prev)) {
                stk.push(it);
                it = it->left;
            }
            else if (it->right && it->right != prev) {
                stk.push(it);
                it = it->right;
            }
			else {
                res.push_back(it->val);
				if (stk.empty()) break;
				prev = it;
                it = stk.top();
                stk.pop();
			}
        }
        return res;
    }
};

class Solution145_new {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
		TreeNode* it = root;
		TreeNode* pre = NULL;
		stack<TreeNode*> stk;
		while(1) {
			while(it && ((!pre) || it->left != pre)) stk.push(it), it = it->left;
			if (stk.empty()) break;
			it = stk.top();
			if (it->right && it->right != pre) it = it->right;
			else {
				res.push_back(it->val);
				pre = it;
				stk.pop();
				it = NULL;
			}
		}
		return res;
    }
};

class Solution159 {
public:
	int lengthOfLongestSubstringTwoDistinct(string s) {
		vector<int> total(256, 0);
		int k = 2;
		int i = 0, j = 0, longest = 0;
		int cur = 0;
		while (j < s.size()) {
			if (total[s[j]] > 0 || cur < k) {
				if (total[s[j]] == 0) cur++;
				total[s[j]]++;
				longest = max(longest, j - i + 1);
				j++;
			}
			else {
				total[s[i]]--;
				if (total[s[i]] == 0) cur--;
				i++;
			}
		}
		return longest;
	}
};

class BSTIterator {
private:
	TreeNode* cur;
	stack<TreeNode*> stk;
public:
	BSTIterator(TreeNode *root) {
		if (!root) {
			cur = NULL;
			return;
		}
		while (root->left) stk.push(root), root = root->left;
		cur = root;
	}

	/** @return whether we have a next smallest number */
	bool hasNext() {
		return (cur != NULL);
	}

	/** @return the next smallest number */
	int next() {
		int temp = cur->val;
		cur = cur->right;
		while (cur) cur = cur->left;
		cur = stk.top();
		stk.pop();
		return temp;
	}
};

class Solution200 {
public:
	int numIslands(vector<vector<char>>& grid) {
		if (grid.empty() || grid[0].empty()) return 0;
		int n = grid.size();
		int m = grid[0].size();
		UnionFind uf = UnionFind(m * n + 1);
		int dummy = m * n;
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				int p = i * m + j;
				if (grid[i][j] == '0') {
					uf.connect(dummy, p);
					continue;
				}
				if (j < m - 1 && grid[i][j + 1] == '1') uf.connect(p, p + 1);
				if (i < n - 1 && grid[i + 1][j] == '1') uf.connect(p, p + m);
			}
		}
		return uf.getCount() - 1;
	}
};

class Solution228 {
public:
    vector<string> summaryRanges(vector<int>& nums) {
        vector<string> res;
        if (nums.empty()) return res;
        int start = nums[0];
		int tt = nums[1];
        for(int i = 1; i < (int)nums.size(); i++) {
            if (nums[i] <= nums[i - 1] || nums[i] != nums[i - 1] + 1) {
                if (start == nums[i - 1]) res.push_back("" + start);
                else {
                    string str = to_string((_Longlong)start) + "->" + to_string((_Longlong)nums[i - 1]);
                    res.push_back(str);
                }
                start = nums[i];
            }
        }
        if (start == nums[nums.size() - 1]) res.push_back(to_string((_Longlong)start));
        else {
			string str = to_string((_Longlong)start) + "->" + to_string((_Longlong)nums[nums.size() - 1]);
            res.push_back(str);
            };
        return res;
    }
};

class Solution253 {
private:
	struct comp {
		bool operator()(Interval p1, Interval p2) {
			return (p1.start < p2.start) || (p1.start == p2.start && p1.end < p2.end);
		}
	}mycomp;
public:
	int minMeetingRooms(vector<Interval>& intervals) {
		if (intervals.empty()) return 0;
		sort(intervals.begin(), intervals.end(), mycomp);
		int rooms = 1;
		priority_queue<int, vector<int>, std::greater<int>> pq;
		pq.push(intervals[0].end);
		for (int i = 1; i < intervals.size(); i++) {
		    pq.push(intervals[i].end);
			while (!pq.empty() && intervals[i].start >= pq.top()) pq.pop();
			rooms = max(rooms, (int)pq.size());
		}
		return rooms;
	}
};

class ValidWordAbbr {
private:
    unordered_map<string, vector<string>> mp;
    string Abbr(string word) {
		string abbr = (word.size() > 2) ? word[0] + to_string((_Longlong)word.size() - 2) + word.back() : word;
        return abbr;
    }
public:
    ValidWordAbbr(vector<string> &dictionary) {
        for(int i = 0; i < dictionary.size(); i++) {
            string abbr = Abbr(dictionary[i]);
            if (mp.find(abbr) == mp.end()) mp[abbr].push_back(dictionary[i]);
            else {
                if (find(mp[abbr].begin(), mp[abbr].end(), dictionary[i]) == mp[abbr].end()) mp[abbr].push_back(dictionary[i]);
            }
        }
    }

    bool isUnique(string word) {
        string abbr = Abbr(word);
        if (mp.find(Abbr(word)) == mp.end()) return true;
        if (mp[abbr].size() > 1) return false;
        return (mp[abbr][0] == word);
    }
};






class Solution285 {
public:
    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
		if (!root || !p) return NULL;
		if (p->right) return p->right;
		stack<TreeNode*> stk;
		TreeNode *it = root;
		while(it != p) {
			stk.push(it);
			if (p->val < it->val) it = it->left;
			else it = it->right;
		}
		while(!stk.empty() && stk.top()->right == it) it = stk.top(), stk.pop();
		return stk.empty() ? NULL :stk.top()->right;
    }
};

/*
class Solution238 {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int> output();
        for(int i = 1; i < nums.size(); i++) {
            output[i] = output[i - 1] * nums[i - 1];
        }
        for(int i = nums.size() - 2; i >= 0; i--) {
            output[i] = output[i + 1] * nums[i + 1];
        }
        return output;
    }
};
*/

class LRUCache{
private:
    unordered_map<int, list<pair<int, int>>::iterator> hashTable;
    list<pair<int, int>> cacheList;
    int m_capacity;
public:
    LRUCache(int capacity) {
        this->m_capacity = capacity;
    }
    
    int get(int key) {
        if (hashTable.find(key) != hashTable.end()) {
            cacheList.splice(cacheList.begin(), cacheList, hashTable[key]);
			hashTable[key] = cacheList.begin();
			return hashTable[key]->second;
        }
        else return -1;
    }
    
    void set(int key, int value) {
        if (hashTable.find(key) != hashTable.end()) {
			cacheList.splice(cacheList.begin(), cacheList, hashTable[key]);
			cacheList.front().second = value;
        }
        else {
			if (hashTable.size() == m_capacity) hashTable.erase(cacheList.back().first), cacheList.pop_back();
            cacheList.push_front(pair<int, int>(key, value));
            hashTable[key] = cacheList.begin();
        }
    }
};

class Solution285_01 {
public:
    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
		if (!root || !p) return NULL;
		TreeNode *it = root;
		if (p->right) {
			it = p->right;
			while(it->left) it = it->left;
			return it;
		}
		TreeNode *temp = root;
		it = root;
		while(it != p) {
			if (p->val < it->val) temp = it, it = it->left;
			else it = it->right;
		}
		return temp;
    }
};

class MedianFinder {
private:
	priority_queue<int, vector<int>> maxHeap;
	priority_queue<int, vector<int>, std::greater<int>> minHeap;
public:

	// Adds a number into the data structure.
	void addNum(int num) {
		if (maxHeap.empty() || num < maxHeap.top()) maxHeap.push(num);
		else minHeap.push(num);
		if (maxHeap.size() > minHeap.size() + 1) minHeap.push(maxHeap.top()), maxHeap.pop();
		else if (minHeap.size() > maxHeap.size() + 1) maxHeap.push(minHeap.top()), minHeap.pop();
	}

	// Returns the median of current data stream
	double findMedian() {
		if (maxHeap.size() < minHeap.size()) return minHeap.top();
		if (minHeap.size() < maxHeap.size()) return maxHeap.top();
		if (maxHeap.size() == 0) return 0;
		return (double)(maxHeap.top() + minHeap.top()) / 2;
	}
};

/*
class Solution137 {
public:
    int singleNumber(vector<int>& nums) {
        vector<int> bitCount(32, 0);
        int res = 0;
        for(auto n : nums) { 
            for(int i = 0; i < 32; i++) {
                if (n & 1 <<i) bitCount[i] = (bitCount[i] + 1) % 3;
            }
        }
        for(int i = 0; i < 32; i++) {
            res += (bitCount[i] == 1) ? 1<<i : 0;
        }
        return res;
    }
};
*/

class SolutionPG1 {
public:
    TreeNode* tt(string input) {
		if (input.size() == 0) return NULL;
        TreeNode *root = new TreeNode(input[0]);
		TreeNode *t = root;
		stack<TreeNode*> stk;
		for(int i = 1; i < input.size(); i += 2) {
			if (input[i] == '?') {
				t->left = new TreeNode(input[i + 1]);
				stk.push(t);
				t = t->left;
			}
			else if (input[i] == ':') {
				t = stk.top();
				stk.pop();
				while(t->right) t = stk.top(), stk.pop();
				t->right = new TreeNode(input[i + 1]);
				stk.push(t);
				t = t->right;
			}
		}
		return root;

    }
};

class SolutionPGTernaryExpression {
public:
    TreeNode* tt(string input) {
		if (input.size() == 0) return NULL;
		stack<TreeNode*> stk;
		TreeNode* root = new TreeNode(0);
		TreeNode* it = root;
		for(int i = 0; i < input.size(); i+=2){
			it->val = input[i] - '0';
			if (i == input.size() - 1) return root;
			if (input[i + 1] == '?') stk.push(it), it->left = new TreeNode(0), it = it->left;
			else {
				it = stk.top();
				while(it->right) stk.pop(), it = stk.top();
				it->right = new TreeNode(0);
				stk.push(it);
				it = it->right;
			}
		}
		return root;
    }
};
struct Node {
  Node *left;
  Node *right;
  /*no public value */
  //Node *parent;
};

class SolutionPGnextLargestNode {
public:
	void InOrder(Node* root, Node* n, bool &found, Node* &target) {
		if (target) return;
		if (found){
			if (root->left) InOrder(root->left, n, found, target);
			else target = root;
			return;
		}
		else {
			if (root->left) InOrder(root->left, n, found, target);
			if (root == n) found = true;
			if (root->right) InOrder(root->right, n, found, target);
		}
	}
};

class SolutionSH {
private:
	struct myComp {
		bool operator() (pair<unsigned short, unsigned short> node1, pair<unsigned short, unsigned short> node2) {
			return (node1.first > node2.first);
		}
	};
public:
	unsigned __int64 CalculateVolume (const unsigned short *a_board, unsigned short a_w, unsigned short a_h) {
		unsigned __int64 res = 0;
		priority_queue<pair<unsigned short, unsigned short>, vector<pair<unsigned short, unsigned short>>, myComp> pq;
		bool *used = new bool[a_w * a_h];
		unsigned short *level = new unsigned short[a_w * a_h];
		memset(used, 0, a_w * a_h);
		memcpy(level, a_board, a_w * a_h * sizeof(unsigned short));

		//push boardary cells into priority_queue
		//top & bottom row
		for(int i = 0; i < a_w; i++) {
			pq.push(make_pair(a_board[i], i));
			used[i] = true;
			if (a_h > 1) {
				pq.push(make_pair(a_board[(a_h - 1) * a_w + i], (a_h - 1) * a_w + i)); 
				used[(a_h - 1) * a_w + i] = true;
			}
		}
		//left & right column
		for(int i = 1; i < a_h - 1; i++) {
			pq.push(make_pair(a_board[i * a_w], i * a_w));
			used[i * a_w] = true;
			if (a_w > 1) {
				pq.push(make_pair(a_board[(i + 1) * a_w - 1], (i + 1) * a_w - 1)); 
				used[(i + 1) * a_w - 1] = true;
			}
		}

		while(!pq.empty()) {
			unsigned short index = pq.top().second;
			unsigned short x = index % a_w, y = index / a_w;
			pq.pop();
			//left cell
			if (x > 0 && !used[index - 1]) {
				used[index - 1] = true;
				if (level[index] > level[index-1]) res += level[index] - level[index-1], level[index-1] = level[index];
				pq.push(make_pair(level[index - 1], index - 1));
			}
			//right cell
			if (x < a_w - 1 && !used[index + 1]) {
				used[index + 1] = true;
				if (level[index] > level[index+1]) res+= level[index] - level[index+1], level[index+1] = level[index];
				pq.push(make_pair(level[index + 1], index + 1));
			}
			//up cell
			if (y > 0 && !used[index - a_w]) {
				used[index - a_w] = true;
				if (level[index] > level[index-a_w]) res+= level[index] - level[index-a_w], level[index-a_w] = level[index];
				pq.push(make_pair(level[index - a_w], index - a_w));
			}
			//down cell
			if (y < a_h - 1 && !used[index + a_w]) {
				used[index + a_w] = true;
				if (level[index] > level[index+a_w]) res+= level[index] - level[index+a_w], level[index+a_w] = level[index];
				pq.push(make_pair(level[index + a_w], index + a_w));
			}
		}

		delete[] used;
		return res;
	}
};


class String 
{ 
public:
    String()      { m_str = new char[1]; *m_str = 0; }
    ~String();
    String& operator+= (const String& other);

private:
    char* m_str;
};

String::~String() {
    if (m_str){
        delete[] m_str;
        m_str = NULL;
    }
}
String& String::operator+=(const String& other) {
	int n = strlen(m_str), m = strlen(other.m_str);
    char *temp = new char[n + m + 1];
    for(int i = 0; i < n; i++) {
        temp[i] = m_str[i];
    }
    for(int i = 0; i < m; i++) {
		temp[n + i] = other.m_str[i];
    }
    temp[m + n] = '\0';
    delete[] m_str;
	m_str = new char[n + m + 1];
	strcpy(m_str, temp);
    delete[] temp;
	//m_str = temp;
    return *this;
}

/*

//SH solution4
struct Vector3 {
	float x,y,z;

	Vector3(float, float, float);
	float distance(const Vector3 other);

	Vector3 operator + (const Vector3 &other);
	Vector3 operator * (const Vector3 &other);
	//...
};

struct Line;
struct Plane;

struct Object{
	Vector3 position;
	Vector3 orientation;
	Vector3 velocity;

	void update(float dt); 
	//...
};

struct Projectile : Object {
	void update(float dt);  //update state during delta time
};

struct Circular : Object {
	Vector3 center;
	float radius;
	
	bool hitBy(Projectile proj) {
		Line line(proj.position, proj.orientation);
		Plane plane(center, orientation);
		Vector3 interPoint = plane.intersect(line);
		
		return interPoint.distance(Vector3(center));
	}
};

struct Line {
	Vector3 p0;         //(m1, m2, m3)
	Vector3 direction;  //(v1, v2, v3)
	//x = m1 + v1 * t;
	//y = m2 + v2 * t;
	//z = m3 + v3 * t;
	Line(Vector3, Vector3);
};

struct Plane {
	Vector3 p0;         //(n1, n2, n3)
	Vector3 normal;     //(vp1, vp2, vp3)
	//vp1 * (x - n1) + vp2 * (y - n2) + vp3 * (z - n3) = 0;

	Plane(Vector3, Vector3);
	
	Vector3 intersect(Line line) {
		//vp1*(m1+v1*t - n1) + vp2*(m2+v2*t - n2) + vp3*(m3+v3*t - n3) = 0;
		//t = ((n1-m2)*vp1+(n2-m2)*vp2+(n3-m3)*vp3)/(vp1*v1 + vp2*v2 + vp3*v3);

		float m1 = line.p0.x,        m2 = line.p0.y,        m3 = line.p0.z;
		float v1 = line.direction.x, v2 = line.direction.y, v3 = line.direction.z;
		float n1 = p0.x,             n2 = p0.y,             n3 = p0.z;
		float vp1 = normal.x,        vp2 = normal.y,        vp3 = normal.z;
		if (vp1*v1 + vp2*v2 + vp3*v3 == 0) {
			//no intersection
		}
		float t = ((n1-m2)*vp1+(n2-m2)*vp2+(n3-m3)*vp3)/(vp1*v1 + vp2*v2 + vp3*v3);
		return Vector3(m1 + v1 * t, m2 + v2 * t, m3 + v3 * t);
	}
};

*/

class Solution5 {
public:
    string longestPalindrome(string s) {
        vector<vector<bool>> f(s.size(), vector<bool>(s.size(), false));
		//const int n = s.size();
		//bool f[n][n];
		//fill_n(&f, n * n, true);
		int index = 0, len = 1;
		for(int i = 0; i < s.size(); i++) {
			f[i][i] = true;
			for(int j = i - 1; j >= 0; j--) {
				if (j == i - 1) f[j][i] = (s[j] == s[i]);
				else f[j][i] = (s[j] == s[i] && f[j + 1][i - 1]);
				if (f[j][i] && i - j + 1 > len) index = j, len = i - j + 1;
			}
		}
		return s.substr(index, len);
    }
};

class Solution5_01 {
public:
    string longestPalindrome(string s) {
        if (s.size() < 2) return s;
        int index = 0, len = 1;
        for(int i = 1; i < s.size(); i++) {
            int k = i, j = i;
            while(j >= 0 && s[j]==s[i]) j--;
            while(k < s.size() && s[k]==s[i]) k++;
            i = k - 1;
            while(j >= 0 && k < s.size() && s[j] == s[k]) j--, k++;
            if (k - j - 1 > len) index = j + 1, len = k - j - 1;
        }
        return s.substr(index, len);
    }
};



///////////////////

class NumArray {
private:
	int sz;
	vector<int> num;
	vector<int> sum;
	int lowerBit(int i) {
		return i & -i;
	}
public:
	NumArray(vector<int> &nums) {
		sz = nums.size();
		num = vector<int>(sz + 1, 0);
		sum = vector<int>(sz + 1, 0);
		for (int i = 0; i < sz; i++) update(i, nums[i]);
	}

	void update(int i, int val) {
		int idx = i + 1;
		int diff = val - num[idx];
		num[idx] = val;
		while (idx <= sz) {
			sum[idx] += diff;
			idx += lowerBit(idx);
		}
	}

	int getSum(int i) {
		int res = 0;
		while (i > 0) {
			res += sum[i];
			i -= lowerBit(i);
		}
		return res;
	}

	int sumRange(int i, int j) {
		return getSum(i + 1) - getSum(j);
	}
};




class TreeArraySimple {
private:
	int sz;
	vector<int> sum;
	int lowerBit(int i) {
		return i & -i;
	}
public:
	TreeArraySimple(int n) {
		sz = n;
		sum = vector<int>(n, 0);
	}

	void add(int i, int val) {
		while (i <= sz) {
			sum[i] += val;
			i += lowerBit(i);
		}
	}

	int getSum(int i) {
		int ret = 0;
		while (i > 0) {
			ret += sum[i];
			i -= lowerBit(i);
		}
		return ret;
	}

};


class NumMatrix2D {
private:
	int n;
	int m;
	vector<vector<int>> num;
	vector<vector<int>> sum;
	int lowerBit(int i) {
		return i & -i;
	}
	void add(int row, int col, int val) {
		num[row][col] += val;
		for (int i = row; i <= n; i += lowerBit(i)) {
			for (int j = col; j <= m; j += lowerBit(j)) {
				sum[i][j] += val;
			}
		}
	}

	int getSum(int row, int col) {
		int ret = 0;
		for (int i = row; i > 0; i -= lowerBit(i)) {
			for (int j = col; j > 0; j -= lowerBit(j)) {
				ret += sum[i][j];
			}
		}
		return ret;
	}
public:
	NumMatrix2D(vector<vector<int>> &matrix) {
		if (matrix.empty() || matrix[0].empty()) return;
		n = matrix.size();
		m = matrix[0].size();
		num = vector<vector<int>>(n + 1, vector<int>(m + 1, 0));
		sum = vector<vector<int>>(n + 1, vector<int>(m + 1, 0));
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				update(i, j, matrix[i][j]);
			}
		}
	}

	void update(int row, int col, int val) {
		if (n == 0 || m == 0) return;
		add(row + 1, col + 1, val - num[row + 1][col + 1]);
	}

	int sumRegion(int row1, int col1, int row2, int col2) {
		if (n == 0 || m == 0) return 0;
		return getSum(row2 + 1, col2 + 1) - getSum(row2 + 1, col1) - getSum(row1, col2 + 1) + getSum(row1, col1);
	}
};

class Solution {
public:
	vector<int> countSmaller(vector<int>& nums) {
		vector<int> res;
		if (nums.empty()) return res;
		res.resize(nums.size());
		vector<int> _nums(nums);
		sort(_nums.begin(), _nums.end());

		unordered_map<int, int> dict;
		for (int i = 0; i < _nums.size(); i++) {
			dict[_nums[i]] = i + 1;
		}

		TreeArraySimple treeArray(nums.size());

		for (int i = nums.size() - 1; i >= 0; i--) {
			res[i] = treeArray.getSum(dict[nums[i]]);
			treeArray.add(dict[nums[i]], 1);
		}

		return res;
	}
};


class TrieNode {
public:
	static const int charSize = 26;
	TrieNode* next[26];
	bool end;
	// Initialize your data structure here.
	TrieNode() {
		end = false;
		memset(next, 0, sizeof(next));
	}
};

class Trie {
public:
	Trie() {
		root = new TrieNode();
	}

	// Inserts a word into the trie.
	void insert(string word) {
		TrieNode* p = root;
		for (int i = 0; i < word.size(); i++) {
			if (!p->next[word[i] - 'a']) p->next[word[i] - 'a'] = new TrieNode();
			p = p->next[word[i] - 'a'];
		}
		p->end = true;
	}

	// Returns if the word is in the trie.
	bool search(string word) {
		TrieNode* p = wordMatch(word);
		return (p && p->end);
	}

	// Returns if there is any word in the trie
	// that starts with the given prefix.
	bool startsWith(string prefix) {
		return (wordMatch(prefix));
	}

private:
	TrieNode* root;
	TrieNode* wordMatch(string word) {
		TrieNode* p = root;
		for (int i = 0; i < word.size(); i++) {
			if (!p->next[word[i] - 'a']) return NULL;
			p = p->next[word[i] - 'a'];
		}
		return p;
	}
};

// Your Trie object will be instantiated and called as such:
// Trie trie;
// trie.insert("somestring");
// trie.search("key");


int main(){
	//Solution105 sln;
	/*
	TreeNode *root = new TreeNode(3);
	root->left = new TreeNode(9);
	root->right = new TreeNode(20);
	root->right->left = new TreeNode(15);
	root->right->right = new TreeNode(7);
	//TreeNode* res = sln.tt(s);
	int height[] = {4,2,0,3,2,5};
	vector<int> heights(begin(height), end(height));
	*/
	
	/*
	TreeNode *root = new TreeNode(1);
	root->right = new TreeNode(2);
	root->right->left = new TreeNode(3);
	int pre[] = {1,2,3};
	int in[] = {2,1,3};
	vector<int> preorder(begin(pre), end(pre));
	vector<int> inorder(begin(in), end(in));
	TreeNode *res = NULL;
	res = sln.buildTree(preorder, inorder);
	*/
	Solution159 sln;
	string s = "aaabc";
	int res = sln.lengthOfLongestSubstringTwoDistinct(s);
	return 0;
}
